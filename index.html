<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Dogfight Destruction v1.0</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  *{box-sizing:border-box;margin:0;padding:0;}
  html,body{width:100%;height:100%;overflow:hidden;font-family:'Inter',sans-serif;background:#60A5FA;color:#0b2447;}
  #gameCanvas{display:block;background:#bfdbfe;position:absolute;top:0;left:0;z-index:1;}
  .ui-container{position:absolute;top:0;left:0;width:100%;height:100%;z-index:4;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;align-items:center;}
  #scoreDisplay{font-size:2.4rem;font-weight:900;margin-top:1.5rem;text-shadow:0 0 8px rgba(255,255,255,0.3);pointer-events:auto;color:#0b2447;}
  #messageOverlay{font-size:1.1rem;font-weight:700;text-align:center;animation:pulse 2s infinite;pointer-events:auto;color:#07203b;}
  @keyframes pulse{0%{opacity:1;transform:scale(1);}50%{opacity:0.8;transform:scale(1.02);}100%{opacity:1;}}
  #gameOverModal{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:6;background-color:#111827;padding:2rem;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.45);text-align:center;display:none;pointer-events:auto;color:#e6eef9;}
  #gameOverModal h1{font-size:2rem;margin-bottom:0.5rem;}
  #gameOverModal p{font-size:1rem;margin-bottom:1rem;color:#cbd5e1;}
  #restartButton{font-family:'Inter',sans-serif;background:#3B82F6;color:white;border:none;padding:0.8rem 1.4rem;border-radius:8px;font-size:1rem;font-weight:800;cursor:pointer;transition:all 0.18s ease;box-shadow:0 6px 18px rgba(59,130,246,0.25);}
  #restartButton:hover{transform:translateY(-3px); background:#2563EB;}
  .touch-zone{position:absolute;top:0;width:50%;height:100%;z-index:3;pointer-events:auto;}
  #touchLeft{left:0;}
  #touchRight{right:0;}
  .hint { position:absolute; bottom:18px; left:50%; transform:translateX(-50%); font-weight:700; pointer-events:none; color:rgba(3,37,65,0.9);}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div class="touch-zone" id="touchLeft"></div>
<div class="touch-zone" id="touchRight"></div>

<div class="ui-container">
  <div id="scoreDisplay">0</div>
  <div id="messageOverlay">Tap/Press Left/Right to Steer-Spacebar to Shoot · Press any key to Start<br>Press <strong>P</strong> to Pause</div>
</div>

<div id="gameOverModal">
  <h1>Game Over</h1>
  <p>Score: <strong><span id="finalScore">0</span></strong></p>
  <p>High Score: <strong><span id="bestScore">0</span></strong></p>
  <button id="restartButton">Retry</button>
</div>

<script>
/* ============================
    Setup + constants
    ============================ */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('scoreDisplay');
const messageOverlay = document.getElementById('messageOverlay');
const gameOverModal = document.getElementById('gameOverModal');
const finalScoreDisplay = document.getElementById('finalScore');
const bestScoreDisplay = document.getElementById('bestScore');
const restartButton = document.getElementById('restartButton');
const touchLeft = document.getElementById('touchLeft');
const touchRight = document.getElementById('touchRight');

let gameState = 'menu'; // menu | playing | paused | gameOver
let score = 0, lastTime = 0, gameTime = 0;

/* === Anti-Cheat Vars === */
let antiCheatTimer = 0;
let turnCheatTimer = 0;
let fireCheatTimer = 0; // <-- NEW: Timer for fire-only cheat
let antiCheatTriggered = false;

const camera = { x:0, y:0 };
const PLAYER_SPEED = 120;
const PLAYER_TURN_SPEED = 3.5;
const JET_WIDTH = 48, JET_HEIGHT = 48, JET_RADIUS = 16;
const ENEMY_SPEED = 120, ENEMY_TURN_SPEED = 2.1;
const MAX_ENEMIES = 5;
let spawnTimer = 0, spawnInterval = 4.5;

const input = { left:false, right:false, fire:false };
let player = null, enemies = [], particles = [], contrails = [], bullets = [];
let lastShotTime = 0, SHOT_COOLDOWN = 5 /*ms*/, BULLET_SPEED = 2400, BULLET_RADIUS = 5;
let highScore = Number(localStorage.getItem('jet_dogfight_high') || 0);

const MINIMAP_SCOPE = 4000;
const ENEMY_SPAWN_INVULN = 1.5;
const DEBUG = false;

/* ============================
    Inline SVG sprites -> data URLs
    ============================ */
const svgPlayer = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <g transform="translate(32,32)">
    <polygon points="0,-28 8,-8 20,0 8,8 0,28 -8,8 -20,0 -8,-8" fill="#3B82F6" stroke="#1e3a8a" stroke-width="1"/>
    <polygon points="0,-24 5,-8 12,0 5,8 0,24 -5,8 -12,0 -5,-8" fill="#60A5FA"/>
    <ellipse cx="0" cy="-8" rx="4" ry="5" fill="#93C5FD"/>
    <polygon points="-6,12 -10,18 -6,12" fill="#1e3a8a" opacity="0.6"/>
    <polygon points="6,12 10,18 6,12" fill="#1e3a8a" opacity="0.6"/>
  </g>
</svg>`;

const svgEnemy = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <g transform="translate(32,32)">
    <polygon points="0,-28 8,-8 20,0 8,8 0,28 -8,8 -20,0 -8,-8" fill="#EF4444" stroke="#7f1d1d" stroke-width="1"/>
    <polygon points="0,-24 5,-8 12,0 5,8 0,24 -5,8 -12,0 -5,-8" fill="#F87171"/>
    <ellipse cx="0" cy="-8" rx="4" ry="5" fill="#FECACA"/>
    <polygon points="-6,12 -10,18 -6,12" fill="#7f1d1d" opacity="0.6"/>
    <polygon points="6,12 10,18 6,12" fill="#7f1d1d" opacity="0.6"/>
  </g>
</svg>`;

function svgToImg(svgString, onload) {
  const img = new Image();
  img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgString);
  img.onload = () => { if (onload) onload(img); };
  img.onerror = () => { console.warn('Failed to load inline SVG image.'); if (onload) onload(img); };
  return img;
}

const imgPlayerJet = svgToImg(svgPlayer);
const imgEnemyJet  = svgToImg(svgEnemy);

/* ============================
    Utility helpers
    ============================ */
function resizeCanvas(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
function rand(min,max){ return Math.random()*(max-min)+min; }
function getDistance(x1,y1,x2,y2){ return Math.hypot(x2 - x1, y2 - y1); }
function wrapAngle(a){ return (a + Math.PI) % (Math.PI*2) - Math.PI; }
function createJet(x,y,angle,speed,turnSpeed,color,type){
  return { x,y,angle,speed,turnSpeed,color,type,width:JET_WIDTH,height:JET_HEIGHT,radius:JET_RADIUS,velX:0,velY:0,spawnTime:gameTime };
}

/* ============================
    Game lifecycle
    ============================ */
function resetGame(){
  player = createJet(0,0,-Math.PI/2,PLAYER_SPEED,PLAYER_TURN_SPEED,'#3B82F6','player');
  enemies = []; particles = []; contrails = []; bullets = [];
  score = 0; gameTime = 0; spawnTimer = 1.8; spawnInterval = 4.5;
  gameState = 'playing';
  gameOverModal.style.display = 'none';
  messageOverlay.style.display = 'none';
  scoreDisplay.style.display = 'block';
  // reset anti-cheat tracking
  antiCheatTimer = 0;
  turnCheatTimer = 0;
  fireCheatTimer = 0; // <-- NEW: Reset new timer
  antiCheatTriggered = false;
}

function spawnEnemy(){
  if (enemies.length >= MAX_ENEMIES) return;
  const spawnAngle = Math.random()*Math.PI*2;
  const spawnDist = Math.max(canvas.width, canvas.height)*0.8;
  const x = player.x + Math.cos(spawnAngle)*spawnDist;
  const y = player.y + Math.sin(spawnAngle)*spawnDist;
  const angle = Math.atan2(player.y - y, player.x - x);
  enemies.push(createJet(x,y,angle,ENEMY_SPEED,ENEMY_TURN_SPEED,'#EF4444','enemy'));
}

function createExplosion(x,y,count){
  for(let i=0;i<count;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = rand(40,220);
    const life = rand(0.6,1.6);
    particles.push({ x,y,dx:Math.cos(angle)*speed,dy:Math.sin(angle)*speed,life,maxLife:life,size:rand(2,5) });
  }
}

function showGameOver(){
  gameState = 'gameOver';
  scoreDisplay.style.display = 'none';
  messageOverlay.style.display = 'none';
  finalScoreDisplay.textContent = score;
  if (score > highScore){ highScore = score; localStorage.setItem('jet_dogfight_high', highScore); }
  bestScoreDisplay.textContent = highScore;
  gameOverModal.style.display = 'block';
  gameOverModal.querySelector('h1').textContent = 'Game Over';
}

/* ============================
    Anti-Cheat: Special end screen
    ============================ */
function showAntiCheat(){
  gameState = 'gameOver';
  scoreDisplay.style.display = 'none';
  messageOverlay.style.display = 'none';
  finalScoreDisplay.textContent = score;
  if (score > highScore){ highScore = score; localStorage.setItem('jet_dogfight_high', highScore); }
  bestScoreDisplay.textContent = highScore;
  gameOverModal.style.display = 'block';
  gameOverModal.querySelector('h1').textContent = 'Anti Cheat Is: Active';
  restartButton.textContent = 'Restart Game';
}

/* ============================
    Drawing jets using images
    ============================ */
function drawJet(ctx, ent){
  ctx.save();
  ctx.translate(ent.x, ent.y);
  ctx.rotate(ent.angle);
  const img = ent.type === 'player' ? imgPlayerJet : imgEnemyJet;
  const w = ent.width;
  const h = ent.height;
  if (img && img.complete && img.width){
    ctx.drawImage(img, -w/2, -h/2, w, h);
  } else {
    ctx.fillStyle = ent.color;
    ctx.beginPath();
    ctx.moveTo(h/2,0);
    ctx.lineTo(-h/2, w/2);
    ctx.lineTo(-h/3,0);
    ctx.lineTo(-h/2, -w/2);
    ctx.closePath();
    ctx.fill();
  }
  if (ent.type === 'enemy' && gameTime - ent.spawnTime < ENEMY_SPAWN_INVULN) {
    ctx.globalAlpha = 0.6;
  }
  if (DEBUG){
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0,0,ent.radius,0,Math.PI*2);
    ctx.stroke();
  }
  ctx.restore();
}

/* ============================
    Update loop
    ============================ */
function update(dt){
  if (!dt || isNaN(dt)) return;
  if (gameState !== 'playing') return;
  gameTime += dt;

  // === Anti-Cheat: Holding turn for 10 seconds ===
  if (input.left || input.right) {
    turnCheatTimer += dt;
    if (turnCheatTimer >= 10 && !antiCheatTriggered) {
      antiCheatTriggered = true;
      createExplosion(player.x, player.y, 30);
      showAntiCheat();
      return; // stop further updates
    }
  } else {
    turnCheatTimer = 0;
  }

  // === Anti-cheat: Holding fire + left/right continuously for 5 seconds ===
  if (input.fire && (input.left || input.right)) {
    antiCheatTimer += dt;
    if (antiCheatTimer >= 5 && !antiCheatTriggered) {
      antiCheatTriggered = true;
      createExplosion(player.x, player.y, 30);
      showAntiCheat();
      return; // stop further updates after anti-cheat triggers
    }
  } else {
    antiCheatTimer = 0;
  }
  
  // === NEW Anti-Cheat: Holding fire for 10 seconds ===
  if (input.fire) {
    fireCheatTimer += dt;
    if (fireCheatTimer >= 10 && !antiCheatTriggered) {
      antiCheatTriggered = true;
      createExplosion(player.x, player.y, 30);
      showAntiCheat();
      return; // stop further updates
    }
  } else {
    fireCheatTimer = 0;
  }

  // player steering & drift
  if (input.left) player.angle -= player.turnSpeed * dt;
  if (input.right) player.angle += player.turnSpeed * dt;
  player.velX += Math.cos(player.angle) * player.speed * dt * 0.55;
  player.velY += Math.sin(player.angle) * player.speed * dt * 0.55;
  player.velX *= 0.92;
  player.velY *= 0.92;
  player.x += player.velX;
  player.y += player.velY;

  // contrails
  contrails.push({ x:player.x, y:player.y, angle:player.angle, life:1 });
  if (contrails.length > 360) contrails.shift();

  // enemies AI
  for (let i=enemies.length-1;i>=0;i--){
    let e = enemies[i];
    const targ = Math.atan2(player.y - e.y, player.x - e.x);
    let diff = wrapAngle(targ - e.angle);
    const dir = Math.sign(diff);
    e.angle += Math.min(Math.abs(diff), e.turnSpeed * dt) * dir;
    e.x += Math.cos(e.angle) * e.speed * dt;
    e.y += Math.sin(e.angle) * e.speed * dt;
  }

  // spawn enemies
  spawnTimer -= dt;
  if (spawnTimer <= 0){
    spawnEnemy();
    spawnTimer = spawnInterval;
    if (spawnInterval > 1.2) spawnInterval *= 0.97;
  }

  // collisions: enemy vs enemy
  for (let i = enemies.length - 1; i >= 0; i--){
    for (let j = i-1; j >= 0; j--){
      if (i >= enemies.length || j >= enemies.length) continue;
      let a = enemies[i], b = enemies[j];
      if (gameTime - a.spawnTime < ENEMY_SPAWN_INVULN || gameTime - b.spawnTime < ENEMY_SPAWN_INVULN) continue;
      if (getDistance(a.x,a.y,b.x,b.y) < a.radius + b.radius){
        createExplosion(a.x,a.y,12);
        createExplosion(b.x,b.y,12);
        enemies.splice(i,1);
        enemies.splice(j,1);
        score += 200;
        break;
      }
    }
  }

  // collisions: player vs enemy
  for (let i = enemies.length -1; i>=0; i--){
    const e = enemies[i];
    if (gameTime - e.spawnTime < ENEMY_SPAWN_INVULN) continue;
    if (getDistance(player.x,player.y,e.x,e.y) < player.radius + e.radius){
      createExplosion(player.x,player.y,28);
      showGameOver();
      return;
    }
  }

  // particles update
  for (let i = particles.length-1; i>=0; i--){
    let p = particles[i];
    p.x += p.dx * dt; p.y += p.dy * dt; p.life -= dt;
    if (p.life <= 0) particles.splice(i,1);
  }

  // firing
  if (input.fire){
    if (performance.now() - lastShotTime > SHOT_COOLDOWN){
      spawnBulletFromJet(player);
      lastShotTime = performance.now();
    }
  }

  // bullets update + collisions vs enemies
  for (let i = bullets.length-1; i>=0; i--){
    let b = bullets[i];
    b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
    if (b.life <= 0){ bullets.splice(i,1); continue; }
    for (let j = enemies.length-1; j>=0; j--){
      let e = enemies[j];
      if (getDistance(b.x,b.y,e.x,e.y) < BULLET_RADIUS + e.radius){
        createExplosion(e.x,e.y,14);
        enemies.splice(j,1);
        bullets.splice(i,1);
        score += 100;
        break;
      }
    }
  }

  scoreDisplay.textContent = score;
}

/* ============================
    Mini map
    ============================ */
function drawMiniMap(){
  const mapSize = 140; const mapMargin = 16;
  const mapX = canvas.width - mapSize - mapMargin; const mapY = mapMargin;
  const scale = mapSize / MINIMAP_SCOPE;
  ctx.save(); ctx.translate(mapX,mapY);
  ctx.fillStyle = 'rgba(0,0,0,0.28)'; ctx.fillRect(0,0,mapSize,mapSize);
  ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.6; ctx.strokeRect(0,0,mapSize,mapSize);
  // player dot center
  ctx.globalAlpha = 1.0;
  ctx.fillStyle = player.color; ctx.beginPath(); ctx.arc(mapSize/2, mapSize/2, 3, 0, Math.PI*2); ctx.fill();
  for (let e of enemies){
    const rx = e.x - player.x, ry = e.y - player.y;
    const dx = (rx * scale) + (mapSize/2), dy = (ry * scale) + (mapSize/2);
    ctx.globalAlpha = (gameTime - e.spawnTime < ENEMY_SPAWN_INVULN) ? 0.5 : 1.0;
    if (dx > 0 && dx < mapSize && dy > 0 && dy < mapSize){
      ctx.fillStyle = '#EF4444'; ctx.beginPath(); ctx.arc(dx,dy,2,0,Math.PI*2); ctx.fill();
    }
  }
  ctx.globalAlpha = 1.0; ctx.restore();
}

/* ============================
    Draw everything
    ============================ */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  camera.x = (player && player.x !== undefined) ? player.x : 0;
  camera.y = (player && player.y !== undefined) ? player.y : 0;

  ctx.save();
  ctx.translate(canvas.width/2 - camera.x, canvas.height/2 - camera.y);

  // contrails
  for (let s of contrails){
    s.life -= 0.02;
    ctx.save();
    ctx.translate(s.x, s.y); ctx.rotate(s.angle);
    ctx.fillStyle = `rgba(255,255,255,${Math.max(0, s.life * 0.45)})`;
    ctx.fillRect(-12, -2.5, 24, 5);
    ctx.restore();
  }

  // particles
  for (let p of particles){
    ctx.fillStyle = `rgba(255,165,0,${Math.max(0, p.life/p.maxLife)})`;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
  }

  // bullets
  for (let b of bullets){
    ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(b.x,b.y,BULLET_RADIUS,0,Math.PI*2); ctx.fill();
  }

  // draw jets
  if (player && player.x !== undefined) drawJet(ctx, player);
  for (let e of enemies) drawJet(ctx, e);

  ctx.restore();

  if (player && player.x !== undefined) drawMiniMap();
}

/* ============================
    Input handlers & spawn bullets
    ============================ */
restartButton.addEventListener('click', resetGame);
window.addEventListener('resize', resizeCanvas);

window.addEventListener('keydown', e => {
  if (gameState === 'menu'){
    resetGame(); return;
  }

  if ((e.key === 'p' || e.key === 'P')) {
    if (gameState === 'playing') {
      gameState = 'paused';
      messageOverlay.textContent = 'PAUSED · Press P to Resume';
      messageOverlay.style.display = 'block';
    } else if (gameState === 'paused') {
      gameState = 'playing';
      messageOverlay.style.display = 'none';
    }
  }

  if (e.key === 'ArrowLeft') input.left = true;
  if (e.key === 'ArrowRight') input.right = true;
  if (e.code === 'Space') input.fire = true;
});

window.addEventListener('keyup', e => {
  if (e.key === 'ArrowLeft') input.left = false;
  if (e.key === 'ArrowRight') input.right = false;
  if (e.code === 'Space') input.fire = false;
});

touchLeft.addEventListener('touchstart', e => { e.preventDefault(); input.left = true; if (gameState === 'menu') resetGame(); }, { passive:false });
touchLeft.addEventListener('touchend',   e => { e.preventDefault(); input.left = false; }, { passive:false });
touchRight.addEventListener('touchstart', e => { e.preventDefault(); input.right = true; if (gameState === 'menu') resetGame(); }, { passive:false });
touchRight.addEventListener('touchend',   e => { e.preventDefault(); input.right = false; }, { passive:false });

function spawnBulletFromJet(jet){
  const nose = (jet.height/2) + 6;
  const bx = jet.x + Math.cos(jet.angle) * nose;
  const by = jet.y + Math.sin(jet.angle) * nose;
  bullets.push({ x:bx, y:by, vx:Math.cos(jet.angle)*BULLET_SPEED, vy:Math.sin(jet.angle)*BULLET_SPEED, life:2.2 });
}

function spawnBulletFromCar(car){ spawnBulletFromJet(car); }

/* ============================
    Main loop start
    ============================ */
resizeCanvas();
lastTime = performance.now();
requestAnimationFrame(function loop(t){
  const dt = (t - lastTime) / 1000;
  lastTime = t;
  if (gameState === 'playing') update(dt);
  draw();
  requestAnimationFrame(loop);
});

/* Set initial UI values */
scoreDisplay.textContent = score;
bestScoreDisplay.textContent = highScore;
messageOverlay.style.display = 'block';
</script>

<!-- ============================
     APPENDED: Overheat / Cooldown plugin (unchanged, as you liked)
     ============================ -->
<script>
(function(){
  const SHOOT_LIMIT = 5.0;
  const COOLDOWN = 10.0;
  const BAR_BG = 'rgba(0,0,0,0.36)';
  const BAR_FILL = 'linear-gradient(90deg, #f43f5e 0%, #fb923c 100%)';

  let shootTimer = 0;
  let cooldownTimer = 0;
  let state = 'ready';

  const container = document.createElement('div');
  container.style.position = 'absolute';
  container.style.bottom = '12px';
  container.style.left = '50%';
  container.style.transform = 'translateX(-50%)';
  container.style.width = '220px';
  container.style.height = '14px';
  container.style.background = BAR_BG;
  container.style.borderRadius = '8px';
  container.style.overflow = 'hidden';
  container.style.zIndex = '1000';
  container.style.pointerEvents = 'none';
  document.body.appendChild(container);

  const fill = document.createElement('div');
  fill.style.height = '100%';
  fill.style.width = '100%';
  fill.style.background = BAR_FILL;
  fill.style.transition = 'width 0.06s linear';
  container.appendChild(fill);

  if (typeof spawnBulletFromJet === 'function') {
    const originalSpawn = spawnBulletFromJet;
    window.spawnBulletFromJet = function(jet){
      if (state === 'cooldown') return;
      return originalSpawn.call(this, jet);
    };
  }

  const originalUpdate = window.update;
  if (typeof originalUpdate !== 'function') return;

  window.update = function(dt){
    originalUpdate(dt);

    if (state === 'ready') {
      if (input.fire) {
        shootTimer += dt;
        if (shootTimer >= SHOOT_LIMIT) {
          state = 'cooldown';
          cooldownTimer = COOLDOWN;
        }
      }
    } else if (state === 'cooldown') {
      cooldownTimer -= dt;
      if (cooldownTimer <= 0) {
        cooldownTimer = 0;
        shootTimer = 0;
        state = 'ready';
      }
    }

    if (state === 'ready') {
      const rem = Math.max(0, (SHOOT_LIMIT - shootTimer) / SHOOT_LIMIT);
      fill.style.width = (rem * 100) + '%';
      fill.style.background = BAR_FILL;
    } else {
      const filled = Math.min(1, (COOLDOWN - cooldownTimer) / COOLDOWN);
      fill.style.width = (filled * 100) + '%';
      fill.style.background = BAR_FILL;
    }
  };
})();
</script>

<!-- ============================
     APPENDED: Boss System plugin (flying @ 5000, turret @ 10000)
     No edits to original code.
     ============================ -->
<script>
(function(){
  // Config
  const BOSS1_SCORE = 5000;   // Flying boss
  const BOSS2_SCORE = 10000;  // Stationary turret boss
  const BOSS_BONUS = 2000;

  // Flying boss config (2x size of enemy)
  const BOSS_JET = {
    width: 48*2, height: 48*2, radius: 16*2,
    speed: 150, turnSpeed: 2.3, color: '#DC2626', type:'bossJet',
    maxHp: 40  // needs 40 bullet hits (tune as desired)
  };

  // Turret boss config
  const BOSS_TURRET = {
    radius: 40, type:'bossTurret', maxHp: 60,
    fireCooldown: 0.8, projectileSpeed: 420, projectileRadius: 6
  };

  const HP_BAR = { w: 360, h: 16, y: 18, bg:'rgba(0,0,0,0.35)', fill:'#ef4444', stroke:'#111' };

  const state = {
    active: false,
    current: null, // the boss entity
    type: null,
    defeatedJet: false,
    defeatedTurret: false,
    bossShots: []
  };

  // Prevent regular enemy spawns while boss is active
  if (typeof spawnEnemy === 'function') {
    const origSpawnEnemy = spawnEnemy;
    window.spawnEnemy = function(){
      if (state.active) return; // block spawning during boss
      return origSpawnEnemy.apply(this, arguments);
    };
  }

  // Reset boss state on resetGame
  if (typeof resetGame === 'function') {
    const origReset = resetGame;
    window.resetGame = function(){
      state.active = false;
      state.current = null;
      state.type = null;
      state.bossShots.length = 0;
      // DO NOT reset defeated flags here so score thresholds still work after death
      return origReset.apply(this, arguments);
    };
  }

  function spawnBossJet(){
    // Spawn just offscreen, similar to enemies
    const spawnAngle = Math.random()*Math.PI*2;
    const spawnDist = Math.max(canvas.width, canvas.height)*0.8;
    const x = player.x + Math.cos(spawnAngle)*spawnDist;
    const y = player.y + Math.sin(spawnAngle)*spawnDist;
    const angle = Math.atan2(player.y - y, player.x - x);
    state.current = {
      x, y, angle,
      speed: BOSS_JET.speed,
      turnSpeed: BOSS_JET.turnSpeed,
      width: BOSS_JET.width,
      height: BOSS_JET.height,
      radius: BOSS_JET.radius,
      color: BOSS_JET.color,
      type: BOSS_JET.type,
      hp: BOSS_JET.maxHp, maxHp: BOSS_JET.maxHp
    };
    state.type = 'jet';
    state.active = true;
  }

  function spawnBossTurret(){
    // Place near map center relative to player
    const x = player.x + 0; 
    const y = player.y - 120; // just above player start area
    state.current = {
      x, y, angle: 0,
      type: BOSS_TURRET.type,
      hp: BOSS_TURRET.maxHp, maxHp: BOSS_TURRET.maxHp,
      fireTimer: 0
    };
    state.type = 'turret';
    state.active = true;
  }

  function bossUpdate(dt){
    if (!state.active || !state.current) return;

    if (state.type === 'jet'){
      // Chase player (similar to enemy AI but beefier)
      const b = state.current;
      const targ = Math.atan2(player.y - b.y, player.x - b.x);
      let diff = ((targ - b.angle + Math.PI) % (Math.PI*2)) - Math.PI;
      b.angle += Math.min(Math.abs(diff), b.turnSpeed * dt) * Math.sign(diff);
      b.x += Math.cos(b.angle) * b.speed * dt;
      b.y += Math.sin(b.angle) * b.speed * dt;
    } else if (state.type === 'turret'){
      // Rotate to face player and fire projectiles
      const b = state.current;
      b.angle = Math.atan2(player.y - b.y, player.x - b.x);
      b.fireTimer -= dt;
      if (b.fireTimer <= 0){
        b.fireTimer = BOSS_TURRET.fireCooldown;
        // Fire a projectile towards player
        const vx = Math.cos(b.angle) * BOSS_TURRET.projectileSpeed;
        const vy = Math.sin(b.angle) * BOSS_TURRET.projectileSpeed;
        state.bossShots.push({ x: b.x, y: b.y, vx, vy, r: BOSS_TURRET.projectileRadius, life: 6 });
      }
    }

    // Boss shots update & player collision
    for (let i=state.bossShots.length-1; i>=0; i--){
      const s = state.bossShots[i];
      s.x += s.vx * dt; s.y += s.vy * dt; s.life -= dt;
      if (s.life <= 0){ state.bossShots.splice(i,1); continue; }
      // collision vs player
      const d = Math.hypot(s.x - player.x, s.y - player.y);
      if (d < (s.r + player.radius)){
        createExplosion(player.x, player.y, 28);
        showGameOver();
        return; // stop further processing this frame
      }
    }

    // Player bullets vs boss collision
    for (let i=bullets.length-1; i>=0; i--){
      const b = bullets[i];
      const dx = b.x - state.current.x;
      const dy = b.y - state.current.y;
      const dist = Math.hypot(dx, dy);
      const hitR = (state.type === 'jet') ? state.current.radius : BOSS_TURRET.radius;
      if (dist < (BULLET_RADIUS + hitR)){
        bullets.splice(i,1);
        state.current.hp -= 1; // each bullet = 1 damage (tune if needed)
        // small hit explosion
        particles.push({ x: b.x, y: b.y, dx: rand(-60,60), dy: rand(-60,60), life: 0.3, maxLife: 0.3, size: 3 });
        if (state.current.hp <= 0){
          // Big boom, bonus, clear boss
          createExplosion(state.current.x, state.current.y, 60);
          score += BOSS_BONUS;
          state.active = false;
          if (state.type === 'jet') state.defeatedJet = true;
          if (state.type === 'turret') state.defeatedTurret = true;
          state.type = null;
          state.current = null;
          state.bossShots.length = 0;
          break;
        }
      }
    }
  }

  function bossDraw(){
    if (!state.active || !state.current) return;

    // Draw world-space stuff with same camera transform as your draw()
    ctx.save();
    ctx.translate(canvas.width/2 - camera.x, canvas.height/2 - camera.y);

    if (state.type === 'jet'){
      const b = state.current;
      // Draw big red jet using enemy sprite scaled up
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(b.angle);
      const img = imgEnemyJet;
      const w = b.width, h = b.height;
      if (img && img.complete && img.width){
        ctx.drawImage(img, -w/2, -h/2, w, h);
      } else {
        ctx.fillStyle = b.color;
        ctx.beginPath();
        ctx.moveTo(h/2,0);
        ctx.lineTo(-h/2, w/2);
        ctx.lineTo(-h/3,0);
        ctx.lineTo(-h/2, -w/2);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    } else if (state.type === 'turret'){
      const b = state.current;
      // Base
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.fillStyle = '#7f1d1d';
      ctx.beginPath(); ctx.arc(0,0,BOSS_TURRET.radius,0,Math.PI*2); ctx.fill();
      // Barrel
      ctx.rotate(b.angle);
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(0, -6, BOSS_TURRET.radius+18, 12);
      ctx.restore();
    }

    // Boss projectiles
    for (const s of state.bossShots){
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth = 2; ctx.stroke();
    }

    ctx.restore();

    // Boss HP bar (screen space, top center)
    const hp = state.current ? state.current.hp : 0;
    const maxHp = state.current ? state.current.maxHp : 1;
    const frac = Math.max(0, Math.min(1, hp / maxHp));
    const x = (canvas.width - HP_BAR.w)/2;
    const y = HP_BAR.y;

    ctx.fillStyle = HP_BAR.bg;
    ctx.fillRect(x, y, HP_BAR.w, HP_BAR.h);
    ctx.fillStyle = HP_BAR.fill;
    ctx.fillRect(x, y, HP_BAR.w * frac, HP_BAR.h);
    ctx.strokeStyle = HP_BAR.stroke;
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, HP_BAR.w, HP_BAR.h);
  }

  // Hook into update/draw safely after original + overheat
  const origUpdate = window.update;
  const origDraw = window.draw;

  window.update = function(dt){
    // Spawn logic (one boss at a time)
    if (!state.active && gameState === 'playing'){
      if (!state.defeatedJet && score >= BOSS1_SCORE){
        spawnBossJet();
      } else if (state.defeatedJet && !state.defeatedTurret && score >= BOSS2_SCORE){
        spawnBossTurret();
      }
    }

    origUpdate(dt); // keep original behaviors
    bossUpdate(dt); // then boss behaviors
  };

  window.draw = function(){
    origDraw();     // original drawing first
    bossDraw();     // then boss overlays (boss & hp bar)
  };
})();
</script>

</body>
</html>

<!-- ========== APPENDED SCRIPTS (do not edit existing code above) ========== -->

<!-- 1) Debug score boost key: press B while playing to +5000 -->
<script>
(function(){
  window.addEventListener('keydown', function(e){
    if ((e.key === 'b' || e.key === 'B') && typeof gameState !== 'undefined' && gameState === 'playing'){
      if (typeof score !== 'undefined'){
        score += 5000;
        if (typeof scoreDisplay !== 'undefined' && scoreDisplay) scoreDisplay.textContent = score;
      }
    }
  });
})();
</script>

<!-- 2) Hearts (3 lives) + 1s invincibility + extra hit FX (append-only, fixed reset hook) -->
<script>
(function(){
  const MAX_HEARTS = 3;
  const INVINCIBILITY_MS = 1000;

  let hearts = MAX_HEARTS;
  let invincibleUntil = 0;
  let fx = [];
  let flashAlpha = 0;

  // UI container
  const heartsContainer = document.createElement('div');
  heartsContainer.style.position = 'absolute';
  heartsContainer.style.top = '16px';
  heartsContainer.style.left = '16px';
  heartsContainer.style.zIndex = '1001';
  heartsContainer.style.display = 'flex';
  heartsContainer.style.gap = '6px';
  heartsContainer.style.pointerEvents = 'none';
  document.body.appendChild(heartsContainer);

  function heart(op=1, sc=1){
    const d=document.createElement('div');
    d.style.opacity=op; d.style.transform=`scale(${sc})`;
    d.style.transition='opacity 0.2s ease, transform 0.2s ease';
    d.innerHTML=`<svg viewBox="0 0 24 24" width="24" height="24" xmlns="http://www.w3.org/2000/svg">
      <path d="M12 21s-6.7-4.35-9.33-7.36C-0.48 10.35 1.2 5.7 5.07 5.07 7.3 4.7 9.1 6 12 8.6 14.9 6 16.7 4.7 18.93 5.07c3.86.63 5.55 5.28 2.4 8.57C18.7 16.65 12 21 12 21z"
            fill="#ef4444" stroke="#7f1d1d" stroke-width="1"/></svg>`;
    return d;
  }
  function renderHearts(){
    heartsContainer.innerHTML='';
    for(let i=0;i<MAX_HEARTS;i++){
      heartsContainer.appendChild(heart(i<hearts?1:0.25, i<hearts?1:0.9));
    }
  }
  renderHearts();

  // FX helpers
  function addSparks(x,y,color='#ffd54f',n=18){
    for(let i=0;i<n;i++){
      const a=Math.random()*Math.PI*2, s=140+Math.random()*160, l=0.22+Math.random()*0.35;
      fx.push({x,y,dx:Math.cos(a)*s,dy:Math.sin(a)*s,life:l,maxLife:l,size:2+Math.random()*3,color});
    }
  }
  function addSmoke(x,y,color='rgba(80,80,80,0.5)',n=10){
    for(let i=0;i<n;i++){
      const a=Math.random()*Math.PI*2, s=30+Math.random()*60, l=0.8+Math.random()*0.8;
      fx.push({x,y,dx:Math.cos(a)*s,dy:Math.sin(a)*s,life:l,maxLife:l,size:6+Math.random()*10,color});
    }
  }

  // ✅ Fixed reset hook — run original first, then restore hearts
  if (typeof window.resetGame === 'function'){
    const _r = window.resetGame;
    window.resetGame = function(){
      const result = _r.apply(this, arguments); // original reset
      hearts = MAX_HEARTS;
      invincibleUntil = 0;
      fx.length = 0;
      flashAlpha = 0;
      renderHearts();
      return result;
    };
  }

  // Turn first few “game over” events into damage + invincibility
  const _showGameOver = window.showGameOver;
  window.showGameOver = function(){
    const t = (typeof performance!=='undefined'?performance.now():Date.now());
    if (t < invincibleUntil) return;
    if (hearts > 1){
      hearts--;
      renderHearts();
      invincibleUntil = t + INVINCIBILITY_MS;
      flashAlpha = 0.35;
      if (typeof player !== 'undefined'){ addSparks(player.x,player.y,'#f87171',26); addSmoke(player.x,player.y,'rgba(255,120,120,0.35)',14); }
      return; // consume a heart; do not end game
    }
    _showGameOver(); // out of hearts → normal game over
  };

  // Draw hook: overlay FX + flash
  const _draw = window.draw;
  window.draw = function(){
    _draw();

    // white flash
    if (flashAlpha>0){
      ctx.save(); ctx.globalAlpha = flashAlpha; ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore();
      flashAlpha = Math.max(0, flashAlpha - 0.06);
    }

    // particles in screen coords
    const dt = 1/60;
    for(let i=fx.length-1;i>=0;i--){
      const p=fx[i];
      p.x+=p.dx*dt; p.y+=p.dy*dt; p.life-=dt;
      if(p.life<=0){ fx.splice(i,1); continue; }
      const a=p.life/p.maxLife;
      const sx = p.x - camera.x + canvas.width/2;
      const sy = p.y - camera.y + canvas.height/2;
      ctx.save(); ctx.globalAlpha=a; ctx.fillStyle=p.color;
      ctx.beginPath(); ctx.arc(sx,sy,p.size,0,Math.PI*2); ctx.fill(); ctx.restore();
    }
  };

  // Update hook: ambient smoke when low hearts
  const _update = window.update;
  window.update = function(dt){
    _update(dt);
    if (typeof gameState!=='undefined' && gameState==='playing' && hearts===1 && Math.random()<0.05 && typeof player!=='undefined'){
      addSmoke(player.x,player.y,'rgba(80,80,80,0.6)',2);
    }
  };
})();
</script>
<script>
window.addEventListener('load', function(){
  const btn = document.getElementById('restartButton');
  if (btn && typeof window.resetGame === 'function'){
    btn.removeEventListener('click', resetGame);
    btn.addEventListener('click', () => window.resetGame());
  }
});
</script>
<script>
(function(){
  // --- 1. Configuration ---
  const SCRAP_PER_KILL = 5;       // Scrap from a bullet kill
  const SCRAP_PER_COLLISION = 10; // Scrap from an enemy-enemy crash
  
  // Define the upgrades
  const upgradeConfig = {
    speed: {
      name: "Engine (Lvl {LVL})",
      baseCost: 50,
      costScale: 1.25,
      buff: 0.03, // 3% speed per level
      desc: "Increases player speed. Cost: {COST} Scrap"
    },
    turn: {
      name: "Ailerons (Lvl {LVL})",
      baseCost: 50,
      costScale: 1.25,
      buff: 0.03, // 3% turn speed per level
      desc: "Increases player turn speed. Cost: {COST} Scrap"
    },
    scrap: {
      name: "Bonus (Lvl {LVL})",
      baseCost: 100,
      costScale: 1.5,
      buff: 0.1, // 10% more scrap per level
      desc: "Increases Scrap earned from kills. Cost: {COST} Scrap"
    }
  };

  // --- 2. Load & Setup State ---
  let sessionScrap = 0;
  let totalScrap = Number(localStorage.getItem('jet_dogfight_scrap') || 0);
  
  // Load saved upgrade levels
  let playerUpgrades = {
    speed: Number(localStorage.getItem('jet_upg_speed') || 0),
    turn: Number(localStorage.getItem('jet_upg_turn') || 0),
    scrap: Number(localStorage.getItem('jet_upg_scrap') || 0)
  };

  // Get the base stats from the original constants
  const BASE_PLAYER_SPEED = 120;
  const BASE_PLAYER_TURN = 3.5;

  // --- 3. Create the Shop UI (Dynamically) ---
  const modal = document.getElementById('gameOverModal');
  const restartButton = document.getElementById('restartButton');
  
  // Create our new UI elements
  const shopContainer = document.createElement('div');
  shopContainer.id = "upgradeShop";
  shopContainer.innerHTML = `
    <hr style="border:1px solid #374151; margin: 1.5rem 0;">
    <p style="margin-bottom: 0.5rem; font-size: 1.1rem; color:#cbd5e1;">
      Banked Scrap: <strong><span id="totalScrapDisplay">0</span></strong>
    </p>
    <div id="upgradeButtons" style="display:flex; flex-direction:column; gap:0.5rem; margin-top:0.5rem; margin-bottom:1.5rem; width: 100%; max-width: 300px; margin-left:auto; margin-right:auto;">
    </div>
  `;

  // Inject the shop into the modal, right before the restart button
  if (modal && restartButton) {
    modal.insertBefore(shopContainer, restartButton);
  }

  // Find our newly created elements
  const totalScrapDisplay = document.getElementById('totalScrapDisplay');
  const upgradeButtonContainer = document.getElementById('upgradeButtons');
  
  // --- 4. Shop Logic Functions ---
  
  // Helper to get the cost for a specific level
  function getUpgradeCost(key) {
    const level = playerUpgrades[key];
    const config = upgradeConfig[key];
    return Math.floor(config.baseCost * Math.pow(config.costScale, level));
  }

  // Main function to refresh the shop UI
  function updateShopUI() {
    if (!totalScrapDisplay || !upgradeButtonContainer) return;

    totalScrapDisplay.textContent = totalScrap;
    upgradeButtonContainer.innerHTML = ''; // Clear old buttons

    // Create a button for each upgrade
    for (const key in upgradeConfig) {
      const config = upgradeConfig[key];
      const level = playerUpgrades[key];
      const cost = getUpgradeCost(key);

      const btn = document.createElement('button');
      btn.className = 'upgrade-btn-plugin'; // Use a unique class
      btn.dataset.upgrade = key;
      
      let name = config.name.replace('{LVL}', level);
      let desc = config.desc.replace('{COST}', cost);
      btn.innerHTML = `${name} - <span>${cost} Scrap</span>`;
      btn.title = desc;

      if (totalScrap < cost) {
        btn.disabled = true;
      }

      btn.addEventListener('click', () => buyUpgrade(key));
      upgradeButtonContainer.appendChild(btn);
    }
  }

  // Function to buy an upgrade
  function buyUpgrade(key) {
    const cost = getUpgradeCost(key);
    if (totalScrap >= cost) {
      // 1. Subtract scrap
      totalScrap -= cost;
      
      // 2. Increase level
      playerUpgrades[key]++;
      
      // 3. Save both
      localStorage.setItem('jet_dogfight_scrap', totalScrap);
      localStorage.setItem(`jet_upg_${key}`, playerUpgrades[key]);
      
      // 4. Refresh UI
      updateShopUI();
    }
  }

  // Add the CSS for our new buttons (so we don't modify the HTML <style>)
  const shopStyle = document.createElement('style');
  shopStyle.innerHTML = `
    .upgrade-btn-plugin {
      font-family:'Inter',sans-serif;
      background:#4B5563;
      color:#F3F4F6;
      border: none;
      padding: 0.6rem 1rem;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.18s ease;
      text-align: left;
    }
    .upgrade-btn-plugin span {
      float: right;
      opacity: 0.9;
    }
    .upgrade-btn-plugin:hover {
      background: #6B7280;
    }
    .upgrade-btn-plugin:disabled {
      background: #374151;
      color: #9CA3AF;
      cursor: not-allowed;
      opacity: 0.7;
    }
  `;
  document.head.appendChild(shopStyle);

  // --- 5. Hook into Game Functions ---

  // HOOK 1: `createExplosion` (to grant scrap)
  if (typeof window.createExplosion === 'function') {
    const _origCreateExplosion = window.createExplosion;
    window.createExplosion = function(x, y, count) {
      // This is a kill, check the particle count
      const scrapBuff = 1 + (playerUpgrades.scrap * upgradeConfig.scrap.buff);

      if (count === 14) { // 14 particles = bullet kill
        sessionScrap += Math.floor(SCRAP_PER_KILL * scrapBuff);
      } else if (count === 12) { // 12 particles = collision kill
        sessionScrap += Math.floor(SCRAP_PER_COLLISION * scrapBuff);
      }
      // Call the original function to make the boom
      _origCreateExplosion.apply(this, arguments);
    };
  }
  
  // HOOK 2: `showGameOver` (to bank scrap)
  if (typeof window.showGameOver === 'function') {
    const _origShowGameOver = window.showGameOver;
    window.showGameOver = function() {
      // Add our logic
      totalScrap += sessionScrap;
      localStorage.setItem('jet_dogfight_scrap', totalScrap);
      sessionScrap = 0;
      updateShopUI(); // Refresh the shop text
      
      // Call the original function
      _origShowGameOver.apply(this, arguments);
    };
  }

  // HOOK 3: `showAntiCheat` (also bank scrap)
  if (typeof window.showAntiCheat === 'function') {
    const _origShowAntiCheat = window.showAntiCheat;
    window.showAntiCheat = function() {
      // Add our logic
      totalScrap += sessionScrap;
      localStorage.setItem('jet_dogfight_scrap', totalScrap);
      sessionScrap = 0;
      updateShopUI();
      
      // Call the original function
      _origShowAntiCheat.apply(this, arguments);
    };
  }

  // HOOK 4: `resetGame` (to apply upgrades)
  if (typeof window.resetGame === 'function') {
    const _origResetGame = window.resetGame;
    window.resetGame = function() {
      // Call the original function FIRST to create the `player`
      _origResetGame.apply(this, arguments);

      // Now, apply our buffs to the new `player` object
      if (window.player) {
        const speedBuff = 1 + (playerUpgrades.speed * upgradeConfig.speed.buff);
        const turnBuff = 1 + (playerUpgrades.turn * upgradeConfig.turn.buff);
        
        // Overwrite the stats set by the original reset
        window.player.speed = BASE_PLAYER_SPEED * speedBuff;
        window.player.turnSpeed = BASE_PLAYER_TURN_SPEED * turnBuff;      
      }
      
      // Reset session scrap counter
      sessionScrap = 0;
    };
  }

})();
</script>
<script>
(function(){
  // --- 0. Wait for the page to load ---
  window.addEventListener('DOMContentLoaded', () => {

    // --- 1. Create the HTML elements for the lore screen ---
    const loreOverlay = document.createElement('div');
    loreOverlay.id = "loreOverlay";
    
    const loreContainer = document.createElement('div');
    loreContainer.id = "loreContainer";
    
    const loreContent = document.createElement('div');
    loreContent.id = "loreContent";
    loreContent.innerHTML = `
      <p style="text-align: center; font-size: 1.5em; margin-bottom: 2em;">17th May 2005<br>Iraq</p>
      <p>Extraction of U.S. Troops From Iraq.</p>
      <p>Mission: Destroy all targets.</p>
      <p>Reason: An Iraqi MiG-21 has shot down a UH-60 Carrying Troops to an extraction base, killing all involved.</p>
      <p>Reach far enough into enemy lines to destroy their Cargo Plane carrying Ammunition.</p>
      <p>Be safe, and good luck.</p>
    `;
    
    const skipText = document.createElement('div');
    skipText.id = "loreSkip";
    skipText.textContent = "Press any key to skip...";
    
    loreContainer.appendChild(loreContent);
    loreOverlay.appendChild(loreContainer);
    loreOverlay.appendChild(skipText);
    document.body.appendChild(loreOverlay);

    // --- 2. Create the CSS for the Star Wars effect ---
    const loreStyle = document.createElement('style');
    loreStyle.innerHTML = `
      #loreOverlay {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: #000;
        color: #feda4a; /* Star Wars Yellow */
        font-family: 'Inter', sans-serif;
        z-index: 999;
        display: none; /* Hidden by default */
        overflow: hidden;
      }
      #loreContainer {
        position: absolute;
        top: 50%; left: 50%;
        width: 80%;
        max-width: 600px;
        height: 100%;
        transform: translate(-50%, -50%);
        perspective: 300px; /* The 3D effect */
      }
      #loreContent {
        position: absolute;
        top: 100%; /* Start at the bottom */
        width: 100%;
        transform-origin: 50% 100%;
        transform: rotateX(25deg) translateZ(0); /* The angle */
        animation: scrollLore 18s linear 1s forwards; /* 18s animation, 1s delay */
        text-align: justify;
        font-size: 1.5rem;
        font-weight: 700;
      }
      #loreContent p {
        margin-bottom: 1.2em;
      }
      @keyframes scrollLore {
        from { top: 100%; }
        to { top: -150%; } /* Scroll all the way off screen */
      }
      #loreSkip {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 1rem;
        opacity: 0.7;
        animation: pulse 2s infinite;
      }
    `;
    document.head.appendChild(loreStyle);

    // --- 3. Hook the game's functions ---
    
    let hasPlayedIntro = false;
    let loreTimer = null;
    let skipListener = null;

    // This function will hold the "real" resetGame
    const _origResetGame = window.resetGame;
    
    // This is the function that will actually end the intro
    const finishIntroAndStartGame = () => {
      // Clear the timer and remove the "skip" listener
      clearTimeout(loreTimer);
      window.removeEventListener('keydown', skipListener);
      window.removeEventListener('touchstart', skipListener);
      
      // Hide the lore screen
      loreOverlay.style.display = 'none';
      
      // Now, *finally*, call the original game's reset function
      _origResetGame();
    };
    
    // Create the "skip" listener
    skipListener = (e) => {
      e.preventDefault();
      finishIntroAndStartGame();
    };

    // Now, we overwrite the global resetGame with our own hook
    window.resetGame = function() {
      // Check if we are starting from the menu, and haven't seen the intro
      if (window.gameState === 'menu' && !hasPlayedIntro) {
        hasPlayedIntro = true;
        
        // Hijack the game state
        window.gameState = 'lore'; // A new state to prevent other inputs
        
        // Hide the "Press any key to Start" message
        if (window.messageOverlay) {
          window.messageOverlay.style.display = 'none';
        }
        
        // Show our lore screen
        loreOverlay.style.display = 'block';
        
        // Add listeners to skip
        window.addEventListener('keydown', skipListener, { once: true });
        window.addEventListener('touchstart', skipListener, { once: true });
        
        // Set a timer for the animation to finish
        loreTimer = setTimeout(finishIntroAndStartGame, 19000); // 18s animation + 1s delay

      } else {
        // This is a "Retry" from the game over screen,
        // so just run the original function
        _origResetGame.apply(this, arguments);
      }
    };

  });
})();
</script>
<!-- ============================
     SCRAP REWARD, DISPLAY, AND AUTO-UNLOCK + SELECTION
     ============================ -->
<script>
(function(){
  const BOSS_REWARD = 200;

  /* 1. SCRAP COUNTER (top-left, next to hearts) */
  const scrapUI = document.createElement('div');
  scrapUI.id = "scrapCounterUI";
  Object.assign(scrapUI.style,{
    position:'absolute',top:'16px',left:'120px',
    fontFamily:"'Inter',sans-serif",fontWeight:'800',
    fontSize:'1.2rem',color:'#fbbf24',
    textShadow:'0 0 6px rgba(0,0,0,0.6)',zIndex:'1002',pointerEvents:'none'
  });
  document.body.appendChild(scrapUI);
  const updateScrapUI = ()=> scrapUI.textContent = "Scrap: " + (localStorage.getItem('jet_dogfight_scrap')||0);
  updateScrapUI();

  const showScrapPopup = txt=>{
    const el=document.createElement('div');
    el.textContent=txt;
    Object.assign(el.style,{
      position:'absolute',right:'20px',bottom:'60px',
      color:'#22c55e',fontWeight:'800',fontSize:'1.2rem',
      textShadow:'0 0 8px rgba(0,0,0,0.5)',
      transition:'all 1.2s ease-out',zIndex:'2000'
    });
    document.body.appendChild(el);
    requestAnimationFrame(()=>{el.style.transform='translateY(-60px)';el.style.opacity='0';});
    setTimeout(()=>el.remove(),1200);
  };

  /* 2. GIVE SCRAP WHEN A BOSS DIES */
  if (typeof window.update==='function'){
    const origUpdate=window.update;
    window.update=function(dt){
      const beforeJet=window?.state?.defeatedJet;
      const beforeTurret=window?.state?.defeatedTurret;
      origUpdate(dt);
      const afterJet=window?.state?.defeatedJet;
      const afterTurret=window?.state?.defeatedTurret;
      if((afterJet&&!beforeJet)||(afterTurret&&!beforeTurret)){
        let s=Number(localStorage.getItem('jet_dogfight_scrap')||0)+BOSS_REWARD;
        localStorage.setItem('jet_dogfight_scrap',s);
        showScrapPopup(`+${BOSS_REWARD} Scrap (Boss Destroyed!)`);
        updateScrapUI();
        updateJetShopUI();
      }
    };
  }

  /* 3. JET DEFINITIONS */
  const jets={
    tigershark:{name:"F-20 Tigershark",desc:"Balanced starter jet.",speed:120,turn:3.5,cost:0,rotationOffset:0},
    starfighter:{name:"F-104 Starfighter",desc:"Faster but less agile.",speed:160,turn:2.3,cost:300,rotationOffset:Math.PI/2}
  };

  function getOwnedJets(){
    const total=Number(localStorage.getItem('jet_dogfight_scrap')||0);
    let owned=["tigershark"];
    for(const k in jets){if(total>=jets[k].cost)owned.push(k);}
    localStorage.setItem('owned_jets',JSON.stringify(owned));
    return owned;
  }
  function getSelectedJet(){return localStorage.getItem('selected_jet')||'tigershark';}
  function setSelectedJet(k){localStorage.setItem('selected_jet',k);}

  /* 4. ADD SHOP UI TO GAMEOVER MODAL */
  const modal=document.getElementById('gameOverModal');
  const restartButton=document.getElementById('restartButton');
  const shop=document.createElement('div');
  shop.innerHTML=`
    <hr style="border:1px solid #374151;margin:1rem 0;">
    <p style="margin-bottom:0.5rem;font-size:1rem;color:#cbd5e1;">
      Banked Scrap: <strong><span id="jetScrapDisplay">0</span></strong>
    </p>
    <div id="jetButtons" style="display:flex;flex-direction:column;gap:0.5rem;margin:0 auto;width:100%;max-width:300px;"></div>
  `;
  if(modal&&restartButton)modal.insertBefore(shop,restartButton);

  const style=document.createElement('style');
  style.textContent=`
    .jet-btn{
      font-family:'Inter',sans-serif;background:#4B5563;color:#F3F4F6;
      border:none;padding:0.6rem 1rem;border-radius:6px;font-size:0.9rem;
      font-weight:700;cursor:pointer;text-align:left;transition:all .18s ease;
    }
    .jet-btn span{float:right;opacity:.9;}
    .jet-btn:hover{background:#6B7280;}
    .jet-btn:disabled{background:#374151;color:#9CA3AF;cursor:not-allowed;}
    .jet-btn.selected{background:#2563eb;color:white;}
  `;
  document.head.appendChild(style);

  /* 5. UPDATE SHOP CONTENT */
  function updateJetShopUI(){
    const total=Number(localStorage.getItem('jet_dogfight_scrap')||0);
    const owned=getOwnedJets();
    const selected=getSelectedJet();
    const list=document.getElementById('jetButtons');
    const display=document.getElementById('jetScrapDisplay');
    if(!list)return;
    if(display)display.textContent=total;
    list.innerHTML='';
    for(const k in jets){
      const j=jets[k];
      const isOwned=owned.includes(k);
      const isSelected=(selected===k);
      const btn=document.createElement('button');
      btn.className='jet-btn';
      if(isSelected)btn.classList.add('selected');
      btn.disabled=!isOwned;
      btn.innerHTML=`${j.name}<span>${isOwned?(isSelected?'Selected':'Unlocked'):j.cost+' Scrap'}</span><br><small>${j.desc}</small>`;
      btn.onclick=()=>{if(isOwned){setSelectedJet(k);updateJetShopUI();}};
      list.appendChild(btn);
    }
  }

  /* 6. APPLY SELECTED JET STATS ON RESET */
  if(typeof window.resetGame==='function'){
    const origReset=window.resetGame;
    window.resetGame=function(){
      origReset.apply(this,arguments);
      const sel=getSelectedJet();
      const owned=getOwnedJets();
      const jet=jets[sel]||jets.tigershark;
      if(window.player){
        player.speed=jet.speed;
        player.turnSpeed=jet.turn;
        player.rotationOffset=jet.rotationOffset||0;
      }
      if(!owned.includes(sel))setSelectedJet('tigershark');
      updateScrapUI();
      updateJetShopUI();
    };
  }

  /* 7. ROTATE STARFIGHTER SPRITE */
  if(typeof window.drawJet==='function'){
    const origDrawJet=window.drawJet;
    window.drawJet=function(ctx,ent){
      if(ent.type==='player'&&window.player&&player.rotationOffset){
        ctx.save();ctx.translate(ent.x,ent.y);
        ctx.rotate(ent.angle+player.rotationOffset);
        const img=imgPlayerJet;const w=ent.width,h=ent.height;
        if(img&&img.complete&&img.width){ctx.drawImage(img,-w/2,-h/2,w,h);}
        else{ctx.fillStyle=ent.color;ctx.beginPath();ctx.moveTo(h/2,0);ctx.lineTo(-h/2,w/2);ctx.lineTo(-h/3,0);ctx.lineTo(-h/2,-w/2);ctx.closePath();ctx.fill();}
        ctx.restore();
      }else origDrawJet(ctx,ent);
    };
  }

  /* 8. KEEP SCRAP COUNTER SYNCED */
  ['showGameOver','showAntiCheat','resetGame'].forEach(fn=>{
    if(typeof window[fn]==='function'){
      const orig=window[fn];
      window[fn]=function(){const r=orig.apply(this,arguments);updateScrapUI();updateJetShopUI();return r;};
    }
  });

  /* INIT */
  updateScrapUI();
  updateJetShopUI();
})();
</script>
<!-- ============================
     FIX: STARFIGHTER ROTATION & STATS APPLY CORRECTLY
     ============================ -->
<script>
(function(){
  const STARFIGHTER_ROTATION = Math.PI / 2;

  // Reapply stats + rotation after reset
  if (typeof window.resetGame === 'function') {
    const origReset = window.resetGame;
    window.resetGame = function() {
      origReset.apply(this, arguments);

      const selected = localStorage.getItem('selected_jet') || 'tigershark';
      if (window.player) {
        if (selected === 'starfighter') {
          player.speed = 160;
          player.turnSpeed = 2.3;
          player.rotationOffset = STARFIGHTER_ROTATION;
        } else {
          player.speed = 120;
          player.turnSpeed = 3.5;
          player.rotationOffset = 0;
        }
      }
    };
  }

  // Force rotated rendering for Starfighter
  if (typeof window.drawJet === 'function') {
    const origDrawJet = window.drawJet;
    window.drawJet = function(ctx, ent) {
      if (ent.type === 'player' && window.player && player.rotationOffset) {
        ctx.save();
        ctx.translate(ent.x, ent.y);
        ctx.rotate(ent.angle + player.rotationOffset);
        const img = imgPlayerJet;
        const w = ent.width, h = ent.height;
        if (img && img.complete && img.width) {
          ctx.drawImage(img, -w/2, -h/2, w, h);
        } else {
          ctx.fillStyle = ent.color;
          ctx.beginPath();
          ctx.moveTo(h/2, 0);
          ctx.lineTo(-h/2, w/2);
          ctx.lineTo(-h/3, 0);
          ctx.lineTo(-h/2, -w/2);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();
      } else {
        origDrawJet(ctx, ent);
      }
    };
  }
})();
</script>


