<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Dogfight Destruction v1.0</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  *{box-sizing:border-box;margin:0;padding:0;}
  html,body{width:100%;height:100%;overflow:hidden;font-family:'Inter',sans-serif;background:#60A5FA;color:#0b2447;}
  #gameCanvas{display:block;background:#bfdbfe;position:absolute;top:0;left:0;z-index:1;}
  .ui-container{position:absolute;top:0;left:0;width:100%;height:100%;z-index:4;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;align-items:center;}
  #scoreDisplay{font-size:2.4rem;font-weight:900;margin-top:1.5rem;text-shadow:0 0 8px rgba(255,255,255,0.3);pointer-events:auto;color:#0b2447;}
  #messageOverlay{font-size:1.1rem;font-weight:700;text-align:center;animation:pulse 2s infinite;pointer-events:auto;color:#07203b;}
  @keyframes pulse{0%{opacity:1;transform:scale(1);}50%{opacity:0.8;transform:scale(1.02);}100%{opacity:1;transform:scale(1);}}
  #gameOverModal{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:6;background-color:#111827;padding:2rem;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.45);text-align:center;display:none;pointer-events:auto;color:#e6eef9;}
  #gameOverModal h1{font-size:2rem;margin-bottom:0.5rem;}
  #gameOverModal p{font-size:1rem;margin-bottom:1rem;color:#cbd5e1;}
  #restartButton{font-family:'Inter',sans-serif;background:#3B82F6;color:white;border:none;padding:0.8rem 1.4rem;border-radius:8px;font-size:1rem;font-weight:800;cursor:pointer;transition:all 0.18s ease;box-shadow:0 6px 18px rgba(59,130,246,0.25);}
  #restartButton:hover{transform:translateY(-3px); background:#2563EB;}
  .touch-zone{position:absolute;top:0;width:50%;height:100%;z-index:3;pointer-events:auto;}
  #touchLeft{left:0;}
  #touchRight{right:0;}
  .hint { position:absolute; bottom:18px; left:50%; transform:translateX(-50%); font-weight:700; pointer-events:none; color:rgba(3,37,65,0.9);}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<!-- Touch zones -->
<div class="touch-zone" id="touchLeft"></div>
<div class="touch-zone" id="touchRight"></div>

<div class="ui-container">
  <div id="scoreDisplay">0</div>
  <div id="messageOverlay">Tap/Press Left/Right to Steer · Spacebar to Shoot · Press any key to Start<br>Press <strong>P</strong> to Pause</div>
</div>

<div id="gameOverModal">
  <h1>Game Over</h1>
  <p>Your final score is: <strong><span id="finalScore">0</span></strong></p>
  <p>High Score: <strong><span id="bestScore">0</span></strong></p>
  <button id="restartButton">Retry</button>
</div>

<!-- Achievement popup container -->
<div id="achievementContainer" style="position:absolute;top:20px;left:50%;transform:translateX(-50%);z-index:10;pointer-events:none;"></div>

<script>
/* ============================
   Setup + constants
   ============================ */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('scoreDisplay');
const messageOverlay = document.getElementById('messageOverlay');
const gameOverModal = document.getElementById('gameOverModal');
const finalScoreDisplay = document.getElementById('finalScore');
const bestScoreDisplay = document.getElementById('bestScore');
const restartButton = document.getElementById('restartButton');
const touchLeft = document.getElementById('touchLeft');
const touchRight = document.getElementById('touchRight');
const achievementContainer = document.getElementById('achievementContainer');

let gameState = 'menu'; // menu | playing | paused | gameOver
let score = 0, lastTime = 0, gameTime = 0, enemiesDestroyedThisMatch = 0, distanceTraveled = 0;

/* === Anti-Cheat Vars === */
let antiCheatTimer = 0;
let antiCheatTriggered = false;

const camera = { x:0, y:0 };
const PLAYER_SPEED = 120;
const PLAYER_TURN_SPEED = 3.5;
const JET_WIDTH = 48, JET_HEIGHT = 48, JET_RADIUS = 16;
const ENEMY_SPEED = 120, ENEMY_TURN_SPEED = 2.1;
const MAX_ENEMIES = 5;
let spawnTimer = 0, spawnInterval = 4.5;

const input = { left:false, right:false, fire:false };
let player = null, enemies = [], particles = [], contrails = [], bullets = [];
let lastShotTime = 0, SHOT_COOLDOWN = 5 /*ms*/, BULLET_SPEED = 2400, BULLET_RADIUS = 5;
let highScore = Number(localStorage.getItem('jet_dogfight_high') || 0);

const MINIMAP_SCOPE = 4000;
const ENEMY_SPAWN_INVULN = 1.5;
const DEBUG = false;

/* ============================
   Achievements
   ============================ */
const achievements = {
  'Rising Ace': {unlocked:false},
  'Sky Dominator': {unlocked:false},
  'Top Gun': {unlocked:false},
  'Marathon': {unlocked:false},
};

function showAchievementPopup(name){
  const popup = document.createElement('div');
  popup.textContent = `Achievement Unlocked: ${name}`;
  popup.style.cssText = `
    background: rgba(59,130,246,0.9);
    color: white;
    font-weight: 700;
    padding: 0.6rem 1rem;
    border-radius: 8px;
    margin-top: 6px;
    font-family: 'Inter', sans-serif;
    text-align: center;
    opacity: 0;
    transform: translateY(-20px);
    transition: all 0.4s ease-out;
  `;
  achievementContainer.appendChild(popup);
  requestAnimationFrame(()=>{ popup.style.opacity = '1'; popup.style.transform = 'translateY(0)'; });
  setTimeout(()=>{
    popup.style.opacity = '0'; popup.style.transform = 'translateY(-20px)';
    setTimeout(()=>achievementContainer.removeChild(popup), 400);
  }, 2200);
}

function checkAchievements(){
  if(!achievements['Rising Ace'].unlocked && score >=5000){
    achievements['Rising Ace'].unlocked=true;
    showAchievementPopup('Rising Ace');
  }
  if(!achievements['Sky Dominator'].unlocked && score >=10000){
    achievements['Sky Dominator'].unlocked=true;
    showAchievementPopup('Sky Dominator');
  }
  if(!achievements['Top Gun'].unlocked && enemiesDestroyedThisMatch >=50){
    achievements['Top Gun'].unlocked=true;
    showAchievementPopup('Top Gun');
  }
  if(!achievements['Marathon'].unlocked && distanceTraveled >=2600.2){
    achievements['Marathon'].unlocked=true;
    showAchievementPopup('Marathon');
  }
}

/* ============================
   Inline SVG sprites
   ============================ */
const svgPlayer = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <g transform="translate(32,32)">
    <polygon points="0,-28 8,-8 20,0 8,8 0,28 -8,8 -20,0 -8,-8" fill="#3B82F6" stroke="#1e3a8a" stroke-width="1"/>
    <polygon points="0,-24 5,-8 12,0 5,8 0,24 -5,8 -12,0 -5,-8" fill="#60A5FA"/>
    <ellipse cx="0" cy="-8" rx="4" ry="5" fill="#93C5FD"/>
    <polygon points="-6,12 -10,18 -6,12" fill="#1e3a8a" opacity="0.6"/>
    <polygon points="6,12 10,18 6,12" fill="#1e3a8a" opacity="0.6"/>
  </g>
</svg>`;
const svgEnemy = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <g transform="translate(32,32)">
    <polygon points="0,-28 8,-8 20,0 8,8 0,28 -8,8 -20,0 -8,-8" fill="#EF4444" stroke="#7f1d1d" stroke-width="1"/>
    <polygon points="0,-24 5,-8 12,0 5,8 0,24 -5,8 -12,0 -5,-8" fill="#F87171"/>
    <ellipse cx="0" cy="-8" rx="4" ry="5" fill="#FECACA"/>
    <polygon points="-6,12 -10,18 -6,12" fill="#7f1d1d" opacity="0.6"/>
    <polygon points="6,12 10,18 6,12" fill="#7f1d1d" opacity="0.6"/>
  </g>
</svg>`;

function svgToImg(svgString, onload){
  const img = new Image();
  img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgString);
  img.onload = () => { if(onload) onload(img); };
  img.onerror = () => { if(onload) onload(img); };
  return img;
}
const imgPlayerJet = svgToImg(svgPlayer);
const imgEnemyJet  = svgToImg(svgEnemy);

/* ============================
   Utility helpers
   ============================ */
function resizeCanvas(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
function rand(min,max){ return Math.random()*(max-min)+min; }
function getDistance(x1,y1,x2,y2){ return Math.hypot(x2-x1, y2-y1); }
function wrapAngle(a){ return (a + Math.PI) % (Math.PI*2) - Math.PI; }
function createJet(x,y,angle,speed,turnSpeed,color,type){
  return { x,y,angle,speed,turnSpeed,color,type,width:JET_WIDTH,height:JET_HEIGHT,radius:JET_RADIUS,velX:0,velY:0,spawnTime:gameTime };
}

/* ============================
   Game lifecycle
   ============================ */
function resetGame(){
  player = createJet(0,0,-Math.PI/2,PLAYER_SPEED,PLAYER_TURN_SPEED,'#3B82F6','player');
  enemies = []; particles = []; contrails = []; bullets = [];
  score = 0; gameTime = 0; enemiesDestroyedThisMatch=0; distanceTraveled=0;
  spawnTimer = 1.8; spawnInterval = 4.5;
  gameState = 'playing';
  gameOverModal.style.display = 'none';
  messageOverlay.style.display = 'none';
  scoreDisplay.style.display = 'block';
  antiCheatTimer = 0; antiCheatTriggered = false;
  // Reset achievements for testing purposes if needed
  // Object.keys(achievements).forEach(k => achievements[k].unlocked=false);
}

function spawnEnemy(){
  if (enemies.length >= MAX_ENEMIES) return;
  const spawnAngle = Math.random()*Math.PI*2;
  const spawnDist = Math.max(canvas.width, canvas.height)*0.8;
  const x = player.x + Math.cos(spawnAngle)*spawnDist;
  const y = player.y + Math.sin(spawnAngle)*spawnDist;
  const angle = Math.atan2(player.y - y, player.x - x);
  enemies.push(createJet(x,y,angle,ENEMY_SPEED,ENEMY_TURN_SPEED,'#EF4444','enemy'));
}

function createExplosion(x,y,count){
  for(let i=0;i<count;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = rand(40,220);
    const life = rand(0.6,1.6);
    particles.push({ x,y,dx:Math.cos(angle)*speed,dy:Math.sin(angle)*speed,life,maxLife:life,size:rand(2,5) });
  }
}

function showGameOver(){
  gameState = 'gameOver';
  scoreDisplay.style.display = 'none';
  messageOverlay.style.display = 'none';
  finalScoreDisplay.textContent = score;
  if(score>highScore){ highScore=score; localStorage.setItem('jet_dogfight_high',highScore); }
  bestScoreDisplay.textContent = highScore;
  gameOverModal.style.display='block';
}

function showAntiCheat(){
  gameState = 'gameOver';
  scoreDisplay.style.display = 'none';
  messageOverlay.style.display = 'none';
  finalScoreDisplay.textContent = score;
  if(score>highScore){ highScore=score; localStorage.setItem('jet_dogfight_high',highScore); }
  bestScoreDisplay.textContent = highScore;
  gameOverModal.style.display='block';
  gameOverModal.querySelector('h1').textContent='Anti Cheat Is: Active';
  restartButton.textContent='Restart Game';
}

/* ============================
   Drawing
   ============================ */
function drawJet(ctx, ent){
  ctx.save();
  ctx.translate(ent.x, ent.y);
  ctx.rotate(ent.angle);
  const img = ent.type==='player'?imgPlayerJet:imgEnemyJet;
  const w = ent.width, h = ent.height;
  if(img && img.complete && img.width) ctx.drawImage(img,-w/2,-h/2,w,h);
  else{
    ctx.fillStyle=ent.color;
    ctx.beginPath();
    ctx.moveTo(h/2,0); ctx.lineTo(-h/2,w/2); ctx.lineTo(-h/3,0); ctx.lineTo(-h/2,-w/2);
    ctx.closePath(); ctx.fill();
  }
  if(ent.type==='enemy' && gameTime - ent.spawnTime<ENEMY_SPAWN_INVULN) ctx.globalAlpha=0.6;
  ctx.restore();
}

function drawMiniMap(){
  const mapSize=140,mapMargin=16,mapX=canvas.width-mapSize-mapMargin,mapY=mapMargin,scale=mapSize/MINIMAP_SCOPE;
  ctx.save(); ctx.translate(mapX,mapY);
  ctx.fillStyle='rgba(0,0,0,0.28)'; ctx.fillRect(0,0,mapSize,mapSize);
  ctx.strokeStyle='#fff'; ctx.lineWidth=1.6; ctx.strokeRect(0,0,mapSize,mapSize);
  ctx.globalAlpha=1.0; ctx.fillStyle=player.color; ctx.beginPath(); ctx.arc(mapSize/2,mapSize/2,3,0,Math.PI*2); ctx.fill();
  for(let e of enemies){
    const rx=e.x-player.x,ry=e.y-player.y,dx=(rx*scale)+(mapSize/2),dy=(ry*scale)+(mapSize/2);
    ctx.globalAlpha=(gameTime-e.spawnTime<ENEMY_SPAWN_INVULN)?0.5:1.0;
    if(dx>0&&dx<mapSize&&dy>0&&dy<mapSize){ ctx.fillStyle='#EF4444'; ctx.beginPath(); ctx.arc(dx,dy,2,0,Math.PI*2); ctx.fill(); }
  }
  ctx.globalAlpha=1.0; ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  camera.x=player.x; camera.y=player.y;
  ctx.save();
  ctx.translate(canvas.width/2 - camera.x, canvas.height/2 - camera.y);
  for(let s of contrails){ s.life-=0.02; ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(s.angle); ctx.fillStyle=`rgba(255,255,255,${Math.max(0,s.life*0.45)})`; ctx.fillRect(-12,-2.5,24,5); ctx.restore(); }
  for(let p of particles){ ctx.fillStyle=`rgba(255,165,0,${Math.max(0,p.life/p.maxLife)})`; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); }
  for(let b of bullets){ ctx.fillStyle='#ffeb3b'; ctx.beginPath(); ctx.arc(b.x,b.y,BULLET_RADIUS,0,Math.PI*2); ctx.fill(); }
  drawJet(ctx,player); for(let e of enemies) drawJet(ctx,e);
  ctx.restore();
  drawMiniMap();
}

/* ============================
   Update
   ============================ */
function update(dt){
  if(!dt||isNaN(dt)) return;
  if(gameState!=='playing') return;
  gameTime+=dt;
  distanceTraveled += Math.hypot(player.velX,player.velY)*dt;

  if(input.fire && (input.left||input.right)){
    antiCheatTimer+=dt;
    if(antiCheatTimer>=5 && !antiCheatTriggered){ antiCheatTriggered=true; createExplosion(player.x,player.y,60); showAntiCheat(); }
  } else { antiCheatTimer=0; }

  if(input.left){ player.angle-=PLAYER_TURN_SPEED*dt; }
  if(input.right){ player.angle+=PLAYER_TURN_SPEED*dt; }

  player.velX = Math.cos(player.angle)*PLAYER_SPEED;
  player.velY = Math.sin(player.angle)*PLAYER_SPEED;
  player.x += player.velX*dt; player.y += player.velY*dt;

  // Bullets
  for(let i=bullets.length-1;i>=0;i--){
    let b=bullets[i];
    b.x+=Math.cos(b.angle)*BULLET_SPEED*dt;
    b.y+=Math.sin(b.angle)*BULLET_SPEED*dt;
    for(let j=enemies.length-1;j>=0;j--){
      let e=enemies[j];
      if(getDistance(b.x,b.y,e.x,e.y)<BULLET_RADIUS+e.radius){
        enemiesDestroyedThisMatch++; score+=30;
        createExplosion(e.x,e.y,8); bullets.splice(i,1); enemies.splice(j,1); break;
      }
    }
    if(b.x<-1000||b.x>1000||b.y<-1000||b.y>1000) bullets.splice(i,1);
  }

  // Enemy AI
  for(let e of enemies){
    const targetAngle=Math.atan2(player.y-e.y,player.x-e.x);
    let diff=wrapAngle(targetAngle-e.angle);
    e.angle+=Math.sign(diff)*Math.min(Math.abs(diff),e.turnSpeed*dt);
    e.x+=Math.cos(e.angle)*e.speed*dt;
    e.y+=Math.sin(e.angle)*e.speed*dt;
  }

  // Spawning
  spawnTimer-=dt; if(spawnTimer<=0){ spawnEnemy(); spawnTimer=spawnInterval; }

  checkAchievements();
}

/* ============================
   Game Loop
   ============================ */
let lastTimestamp=0;
function gameLoop(ts){
  let dt=(ts-lastTimestamp)/1000;
  lastTimestamp=ts;
  update(dt);
  draw();
  requestAnimationFrame(gameLoop);
}

/* ============================
   Input
   ============================ */
document.addEventListener('keydown',e=>{
  if(e.code==='ArrowLeft'||e.code==='KeyA'){ input.left=true; }
  if(e.code==='ArrowRight'||e.code==='KeyD'){ input.right=true; }
  if(e.code==='Space'){ input.fire=true; }
  if(e.code==='KeyP'){ if(gameState==='playing'){ gameState='paused'; messageOverlay.textContent='PAUSED'; messageOverlay.style.display='block'; } else if(gameState==='paused'){ gameState='playing'; messageOverlay.style.display='none'; } }
  if(gameState==='menu'){ resetGame(); }
});
document.addEventListener('keyup',e=>{
  if(e.code==='ArrowLeft'||e.code==='KeyA'){ input.left=false; }
  if(e.code==='ArrowRight'||e.code==='KeyD'){ input.right=false; }
  if(e.code==='Space'){ input.fire=false; }
});
touchLeft.addEventListener('touchstart',e=>{ e.preventDefault(); input.left=true; });
touchLeft.addEventListener('touchend',e=>{ e.preventDefault(); input.left=false; });
touchRight.addEventListener('touchstart',e=>{ e.preventDefault(); input.right=true; });
touchRight.addEventListener('touchend',e=>{ e.preventDefault(); input.right=false; });

restartButton.addEventListener('click',()=>resetGame());

window.addEventListener('resize',resizeCanvas);
resizeCanvas();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
