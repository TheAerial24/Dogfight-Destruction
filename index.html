<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Dogfight Destruction v1.0</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  *{box-sizing:border-box;margin:0;padding:0;}
  html,body{width:100%;height:100%;overflow:hidden;font-family:'Inter',sans-serif;background:#60A5FA;color:#0b2447;}
  #gameCanvas{display:block;background:#bfdbfe;position:absolute;top:0;left:0;z-index:1;}
  .ui-container{position:absolute;top:0;left:0;width:100%;height:100%;z-index:4;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;align-items:center;}
  #scoreDisplay{font-size:2.4rem;font-weight:900;margin-top:1.5rem;text-shadow:0 0 8px rgba(255,255,255,0.3);pointer-events:auto;color:#0b2447;}
  #messageOverlay{font-size:1.1rem;font-weight:700;text-align:center;animation:pulse 2s infinite;pointer-events:auto;color:#07203b;}
  @keyframes pulse{0%{opacity:1;transform:scale(1);}50%{opacity:0.8;transform:scale(1.02);}100%{opacity:1;transform:scale(1);}}
  #gameOverModal{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:6;background-color:#111827;padding:2rem;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.45);text-align:center;display:none;pointer-events:auto;color:#e6eef9;}
  #gameOverModal h1{font-size:2rem;margin-bottom:0.5rem;}
  #gameOverModal p{font-size:1rem;margin-bottom:1rem;color:#cbd5e1;}
  #restartButton{font-family:'Inter',sans-serif;background:#3B82F6;color:white;border:none;padding:0.8rem 1.4rem;border-radius:8px;font-size:1rem;font-weight:800;cursor:pointer;transition:all 0.18s ease;box-shadow:0 6px 18px rgba(59,130,246,0.25);}
  #restartButton:hover{transform:translateY(-3px); background:#2563EB;}
  .touch-zone{position:absolute;top:0;width:50%;height:100%;z-index:3;pointer-events:auto;}
  #touchLeft{left:0;}
  #touchRight{right:0;}
  .hint { position:absolute; bottom:18px; left:50%; transform:translateX(-50%); font-weight:700; pointer-events:none; color:rgba(3,37,65,0.9);}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div class="touch-zone" id="touchLeft"></div>
<div class="touch-zone" id="touchRight"></div>

<div class="ui-container">
  <div id="scoreDisplay">0</div>
  <div id="messageOverlay">Tap/Press Left/Right to Steer-Spacebar to Shoot · Press any key to Start<br>Press <strong>P</strong> to Pause</div>
</div>

<div id="gameOverModal">
  <h1>Game Over</h1>
  <p>Your final score is: <strong><span id="finalScore">0</span></strong></p>
  <p>High Score: <strong><span id="bestScore">0</span></strong></p>
  <button id="restartButton">Retry</button>
</div>

<script>
/* ============================
    Setup + constants
    ============================ */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('scoreDisplay');
const messageOverlay = document.getElementById('messageOverlay');
const gameOverModal = document.getElementById('gameOverModal');
const finalScoreDisplay = document.getElementById('finalScore');
const bestScoreDisplay = document.getElementById('bestScore');
const restartButton = document.getElementById('restartButton');
const touchLeft = document.getElementById('touchLeft');
const touchRight = document.getElementById('touchRight');

let gameState = 'menu'; // menu | playing | paused | gameOver
let score = 0, lastTime = 0, gameTime = 0;

/* === Anti-Cheat Vars === */
let antiCheatTimer = 0;
let turnCheatTimer = 0;
let fireCheatTimer = 0; // <-- NEW: Timer for fire-only cheat
let antiCheatTriggered = false;

const camera = { x:0, y:0 };
const PLAYER_SPEED = 120;
const PLAYER_TURN_SPEED = 3.5;
const JET_WIDTH = 48, JET_HEIGHT = 48, JET_RADIUS = 16;
const ENEMY_SPEED = 120, ENEMY_TURN_SPEED = 2.1;
const MAX_ENEMIES = 5;
let spawnTimer = 0, spawnInterval = 4.5;

const input = { left:false, right:false, fire:false };
let player = null, enemies = [], particles = [], contrails = [], bullets = [];
let lastShotTime = 0, SHOT_COOLDOWN = 5 /*ms*/, BULLET_SPEED = 2400, BULLET_RADIUS = 5;
let highScore = Number(localStorage.getItem('jet_dogfight_high') || 0);

// === NEW: Overheat constants ===
const SHOT_CAPACITY_MAX = 3.0; // 3 seconds of firing
const SHOT_COOLDOWN_TIME = 5.0; // 5 seconds of cooldown

const MINIMAP_SCOPE = 4000;
const ENEMY_SPAWN_INVULN = 1.5;
const DEBUG = false;

/* ============================
    Inline SVG sprites -> data URLs
    ============================ */
const svgPlayer = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <g transform="translate(32,32)">
    <polygon points="0,-28 8,-8 20,0 8,8 0,28 -8,8 -20,0 -8,-8" fill="#3B82F6" stroke="#1e3a8a" stroke-width="1"/>
    <polygon points="0,-24 5,-8 12,0 5,8 0,24 -5,8 -12,0 -5,-8" fill="#60A5FA"/>
    <ellipse cx="0" cy="-8" rx="4" ry="5" fill="#93C5FD"/>
    <polygon points="-6,12 -10,18 -6,12" fill="#1e3a8a" opacity="0.6"/>
    <polygon points="6,12 10,18 6,12" fill="#1e3a8a" opacity="0.6"/>
  </g>
</svg>`;

const svgEnemy = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <g transform="translate(32,32)">
    <polygon points="0,-28 8,-8 20,0 8,8 0,28 -8,8 -20,0 -8,-8" fill="#EF4444" stroke="#7f1d1d" stroke-width="1"/>
    <polygon points="0,-24 5,-8 12,0 5,8 0,24 -5,8 -12,0 -5,-8" fill="#F87171"/>
    <ellipse cx="0" cy="-8" rx="4" ry="5" fill="#FECACA"/>
    <polygon points="-6,12 -10,18 -6,12" fill="#7f1d1d" opacity="0.6"/>
    <polygon points="6,12 10,18 6,12" fill="#7f1d1d" opacity="0.6"/>
  </g>
</svg>`;

function svgToImg(svgString, onload) {
  const img = new Image();
  img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgString);
  img.onload = () => { if (onload) onload(img); };
  img.onerror = () => { console.warn('Failed to load inline SVG image.'); if (onload) onload(img); };
  return img;
}

const imgPlayerJet = svgToImg(svgPlayer);
const imgEnemyJet  = svgToImg(svgEnemy);

/* ============================
    Utility helpers
    ============================ */
function resizeCanvas(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
function rand(min,max){ return Math.random()*(max-min)+min; }
function getDistance(x1,y1,x2,y2){ return Math.hypot(x2 - x1, y2 - y1); }
function wrapAngle(a){ return (a + Math.PI) % (Math.PI*2) - Math.PI; }

// === MODIFIED: Added shotCapacity and shotCooldown for player ===
function createJet(x,y,angle,speed,turnSpeed,color,type){
  const jet = { x,y,angle,speed,turnSpeed,color,type,width:JET_WIDTH,height:JET_HEIGHT,radius:JET_RADIUS,velX:0,velY:0,spawnTime:gameTime };
  if (type === 'player') {
    jet.shotCapacity = SHOT_CAPACITY_MAX;
    jet.shotCooldown = 0;
  }
  return jet;
}

/* ============================
    Game lifecycle
    ============================ */
function resetGame(){
  player = createJet(0,0,-Math.PI/2,PLAYER_SPEED,PLAYER_TURN_SPEED,'#3B82F6','player');
  enemies = []; particles = []; contrails = []; bullets = [];
  score = 0; gameTime = 0; spawnTimer = 1.8; spawnInterval = 4.5;
  gameState = 'playing';
  gameOverModal.style.display = 'none';
  messageOverlay.style.display = 'none';
  scoreDisplay.style.display = 'block';
  // reset anti-cheat tracking
  antiCheatTimer = 0;
  turnCheatTimer = 0;
  fireCheatTimer = 0; // <-- NEW: Reset new timer
  antiCheatTriggered = false;
}

function spawnEnemy(){
  if (enemies.length >= MAX_ENEMIES) return;
  const spawnAngle = Math.random()*Math.PI*2;
  const spawnDist = Math.max(canvas.width, canvas.height)*0.8;
  const x = player.x + Math.cos(spawnAngle)*spawnDist;
  const y = player.y + Math.sin(spawnAngle)*spawnDist;
  const angle = Math.atan2(player.y - y, player.x - x);
  enemies.push(createJet(x,y,angle,ENEMY_SPEED,ENEMY_TURN_SPEED,'#EF4444','enemy'));
}

function createExplosion(x,y,count){
  for(let i=0;i<count;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = rand(40,220);
    const life = rand(0.6,1.6);
    particles.push({ x,y,dx:Math.cos(angle)*speed,dy:Math.sin(angle)*speed,life,maxLife:life,size:rand(2,5) });
_ }
}

function showGameOver(){
  gameState = 'gameOver';
  scoreDisplay.style.display = 'none';
  messageOverlay.style.display = 'none';
  finalScoreDisplay.textContent = score;
  if (score > highScore){ highScore = score; localStorage.setItem('jet_dogfight_high', highScore); }
  bestScoreDisplay.textContent = highScore;
  gameOverModal.style.display = 'block';
  gameOverModal.querySelector('h1').textContent = 'Game Over';
}

/* ============================
    Anti-Cheat: Special end screen
    ============================ */
function showAntiCheat(){
  gameState = 'gameOver';
  scoreDisplay.style.display = 'none';
  messageOverlay.style.display = 'none';
  finalScoreDisplay.textContent = score;
  if (score > highScore){ highScore = score; localStorage.setItem('jet_dogfight_high', highScore); }
  bestScoreDisplay.textContent = highScore;
  gameOverModal.style.display = 'block';
  gameOverModal.querySelector('h1').textContent = 'Anti Cheat Is: Active';
  restartButton.textContent = 'Restart Game';
}

/* ============================
    Drawing jets using images
    ============================ */
function drawJet(ctx, ent){
  ctx.save();
  ctx.translate(ent.x, ent.y);
  ctx.rotate(ent.angle);
  const img = ent.type === 'player' ? imgPlayerJet : imgEnemyJet;
  const w = ent.width;
  const h = ent.height;
  if (img && img.complete && img.width){
    ctx.drawImage(img, -w/2, -h/2, w, h);
  } else {
    ctx.fillStyle = ent.color;
    ctx.beginPath();
    ctx.moveTo(h/2,0);
    ctx.lineTo(-h/2, w/2);
    ctx.lineTo(-h/3,0);
    ctx.lineTo(-h/2, -w/2);
    ctx.closePath();
    ctx.fill();
  }
  if (ent.type === 'enemy' && gameTime - ent.spawnTime < ENEMY_SPAWN_INVULN) {
    ctx.globalAlpha = 0.6;
  }
  if (DEBUG){
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0,0,ent.radius,0,Math.PI*2);
    ctx.stroke();
  }
  ctx.restore();
}

/* ============================
    Update loop
    ============================ */
function update(dt){
  if (!dt || isNaN(dt)) return;
  if (gameState !== 'playing') return;
  gameTime += dt;

  // === Anti-Cheat: Holding turn for 10 seconds ===
  if (input.left || input.right) {
    turnCheatTimer += dt;
    if (turnCheatTimer >= 10 && !antiCheatTriggered) {
      antiCheatTriggered = true;
      createExplosion(player.x, player.y, 30);
      showAntiCheat();
      return; // stop further updates
    }
  } else {
    turnCheatTimer = 0;
  }

  // === Anti-cheat: Holding fire + left/right continuously for 5 seconds ===
  if (input.fire && (input.left || input.right)) {
    antiCheatTimer += dt;
    if (antiCheatTimer >= 5 && !antiCheatTriggered) {
      antiCheatTriggered = true;
      createExplosion(player.x, player.y, 30);
      showAntiCheat();
      return; // stop further updates after anti-cheat triggers
    }
  } else {
    antiCheatTimer = 0;
  }
  
  // === NEW Anti-Cheat: Holding fire for 10 seconds ===
  if (input.fire) {
    fireCheatTimer += dt;
    if (fireCheatTimer >= 10 && !antiCheatTriggered) {
      antiCheatTriggered = true;
      createExplosion(player.x, player.y, 30);
      showAntiCheat();
      return; // stop further updates
    }
  } else {
    fireCheatTimer = 0;
  }

  // player steering & drift
  if (input.left) player.angle -= player.turnSpeed * dt;
  if (input.right) player.angle += player.turnSpeed * dt;
  player.velX += Math.cos(player.angle) * player.speed * dt * 0.55;
  player.velY += Math.sin(player.angle) * player.speed * dt * 0.55;
  player.velX *= 0.92;
  player.velY *= 0.92;
  player.x += player.velX;
  player.y += player.velY;

  // contrails
  contrails.push({ x:player.x, y:player.y, angle:player.angle, life:1 });
  if (contrails.length > 360) contrails.shift();

  // enemies AI
  for (let i=enemies.length-1;i>=0;i--){
    let e = enemies[i];
    const targ = Math.atan2(player.y - e.y, player.x - e.x);
    let diff = wrapAngle(targ - e.angle);
    const dir = Math.sign(diff);
    e.angle += Math.min(Math.abs(diff), e.turnSpeed * dt) * dir;
    e.x += Math.cos(e.angle) * e.speed * dt;
    e.y += Math.sin(e.angle) * e.speed * dt;
  }

  // spawn enemies
  spawnTimer -= dt;
  if (spawnTimer <= 0){
    spawnEnemy();
    spawnTimer = spawnInterval;
    if (spawnInterval > 1.2) spawnInterval *= 0.97;
  }

  // collisions: enemy vs enemy
  for (let i = enemies.length - 1; i >= 0; i--){
    for (let j = i-1; j >= 0; j--){
      if (i >= enemies.length || j >= enemies.length) continue;
      let a = enemies[i], b = enemies[j];
      if (gameTime - a.spawnTime < ENEMY_SPAWN_INVULN || gameTime - b.spawnTime < ENEMY_SPAWN_INVULN) continue;
Â     if (getDistance(a.x,a.y,b.x,b.y) < a.radius + b.radius){
        createExplosion(a.x,a.y,12);
        createExplosion(b.x,b.y,12);
        enemies.splice(i,1);
        enemies.splice(j,1);
        score += 200;
        break;
      }
    }
  }

  // collisions: player vs enemy
  for (let i = enemies.length -1; i>=0; i--){
    const e = enemies[i];
    if (gameTime - e.spawnTime < ENEMY_SPAWN_INVULN) continue;
    if (getDistance(player.x,player.y,e.x,e.y) < player.radius + e.radius){
      createExplosion(player.x,player.y,28);
      showGameOver();
      return;
    }
  }

  // particles update
  for (let i = particles.length-1; i>=0; i--){
    let p = particles[i];
    p.x += p.dx * dt; p.y += p.dy * dt; p.life -= dt;
    if (p.life <= 0) particles.splice(i,1);
  }

  // === MODIFIED: Firing logic with Overheat ===
  if (player.shotCooldown > 0) {
    // Player is in cooldown
    player.shotCooldown -= dt;
    if (player.shotCooldown <= 0) {
      player.shotCooldown = 0;
      player.shotCapacity = SHOT_CAPACITY_MAX; // Refill!
    }
  } else if (input.fire) {
    // Player is NOT in cooldown and IS firing
    if (player.shotCapacity > 0) {
      // Has capacity, so shoot
      player.shotCapacity -= dt; // Deplete capacity

      if (performance.now() - lastShotTime > SHOT_COOLDOWN){
        spawnBulletFromJet(player);
        lastShotTime = performance.now();
      }

      if (player.shotCapacity <= 0) {
        // Just ran out! Start cooldown.
        player.shotCapacity = 0;
        player.shotCooldown = SHOT_COOLDOWN_TIME;
      }
    }
    // else: player has no capacity, so do nothing (can't shoot)
  }
  // === END MODIFIED Firing logic ===


  // bullets update + collisions vs enemies
  for (let i = bullets.length-1; i>=0; i--){
    let b = bullets[i];
    b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt;
    if (b.life <= 0){ bullets.splice(i,1); continue; }
    for (let j = enemies.length-1; j>=0; j--){
      let e = enemies[j];
      if (getDistance(b.x,b.y,e.x,e.y) < BULLET_RADIUS + e.radius){
        createExplosion(e.x,e.y,14);
        enemies.splice(j,1);
        bullets.splice(i,1);
        score += 100;
        break;
      }
    }
  }

  scoreDisplay.textContent = score;
}

/* ============================
    Mini map
    ============================ */
function drawMiniMap(){
  const mapSize = 140; const mapMargin = 16;
  const mapX = canvas.width - mapSize - mapMargin; const mapY = mapMargin;
  const scale = mapSize / MINIMAP_SCOPE;
  ctx.save(); ctx.translate(mapX,mapY);
  ctx.fillStyle = 'rgba(0,0,0,0.28)'; ctx.fillRect(0,0,mapSize,mapSize);
  ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.6; ctx.strokeRect(0,0,mapSize,mapSize);
  // player dot center
  ctx.globalAlpha = 1.0;
  ctx.fillStyle = player.color; ctx.beginPath(); ctx.arc(mapSize/2, mapSize/2, 3, 0, Math.PI*2); ctx.fill();
  for (let e of enemies){
    const rx = e.x - player.x, ry = e.y - player.y;
    const dx = (rx * scale) + (mapSize/2), dy = (ry * scale) + (mapSize/2);
    ctx.globalAlpha = (gameTime - e.spawnTime < ENEMY_SPAWN_INVULN) ? 0.5 : 1.0;
    if (dx > 0 && dx < mapSize && dy > 0 && dy < mapSize){
      ctx.fillStyle = '#EF4444'; ctx.beginPath(); ctx.arc(dx,dy,2,0,Math.PI*2); ctx.fill();
    }
  }
  ctx.globalAlpha = 1.0; ctx.restore();
}

/* ============================
    NEW: Overheat Bar
    ============================ */
function drawOverheatBar(){
  if (!player) return;

  const barWidth = 160;
  const barHeight = 12;
  const barX = (canvas.width / 2) - (barWidth / 2);
  const barY = 60; // Positioned below the score

  let fillPercent = 1.0;
  let fillColor = 'rgba(255, 235, 59, 0.8)'; // Yellow for capacity

  if (player.shotCooldown > 0) {
    // We are in cooldown
    fillPercent = player.shotCooldown / SHOT_COOLDOWN_TIME;
    fillColor = 'rgba(239, 68, 68, 0.8)'; // Red for overheat
  } else {
    // We are not in cooldown, show capacity
    fillPercent = player.shotCapacity / SHOT_CAPACITY_MAX;
a    fillColor = 'rgba(255, 235, 59, 0.8)'; // Yellow for capacity
  }

  // Draw background
  ctx.fillStyle = 'rgba(0,0,0,0.28)';
  ctx.fillRect(barX, barY, barWidth, barHeight);

  // Draw fill
  ctx.fillStyle = fillColor;
  ctx.fillRect(barX, barY, barWidth * fillPercent, barHeight);
  
  // Draw border
  ctx.strokeStyle = 'rgba(255,255,255,0.7)';
  ctx.lineWidth = 1;
  ctx.strokeRect(barX, barY, barWidth, barHeight);
}


/* ============================
    Draw everything
    ============================ */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  camera.x = (player && player.x !== undefined) ? player.x : 0;
  camera.y = (player && player.y !== undefined) ? player.y : 0;

  ctx.save();
  ctx.translate(canvas.width/2 - camera.x, canvas.height/2 - camera.y);

  // contrails
  for (let s of contrails){
    s.life -= 0.02;
    ctx.save();
    ctx.translate(s.x, s.y); ctx.rotate(s.angle);
    ctx.fillStyle = `rgba(255,255,255,${Math.max(0, s.life * 0.45)})`;
    ctx.fillRect(-12, -2.5, 24, 5);
    ctx.restore();
  }

  // particles
  for (let p of particles){
    ctx.fillStyle = `rgba(255,165,0,${Math.max(0, p.life/p.maxLife)})`;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
  }

  // bullets
  for (let b of bullets){
    ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(b.x,b.y,BULLET_RADIUS,0,Math.PI*2); ctx.fill();
  }

  // draw jets
  if (player && player.x !== undefined) drawJet(ctx, player);
  for (let e of enemies) drawJet(ctx, e);

  ctx.restore();

  // === MODIFIED: Draw HUD elements ===
  if (player && player.x !== undefined) {
    drawMiniMap();
    // Only draw overheat bar when playing
    if (gameState === 'playing') {
      drawOverheatBar();
    }
  }
}

/* ============================
    Input handlers & spawn bullets
    ============================ */
restartButton.addEventListener('click', resetGame);
window.addEventListener('resize', resizeCanvas);

window.addEventListener('keydown', e => {
i  if (gameState === 'menu'){
    resetGame(); return;
  }

  if ((e.key === 'p' || e.key === 'P')) {
    if (gameState === 'playing') {
      gameState = 'paused';
      messageOverlay.textContent = 'PAUSED · Press P to Resume';
      messageOverlay.style.display = 'block';
    } else if (gameState === 'paused') {
      gameState = 'playing';
      messageOverlay.style.display = 'none';
    }
  }

  if (e.key === 'ArrowLeft') input.left = true;
  if (e.key === 'ArrowRight') input.right = true;
  if (e.code === 'Space') input.fire = true;
});

window.addEventListener('keyup', e => {
A  if (e.key === 'ArrowLeft') input.left = false;
  if (e.key === 'ArrowRight') input.right = false;
  if (e.code === 'Space') input.fire = false;
});

touchLeft.addEventListener('touchstart', e => { e.preventDefault(); input.left = true; if (gameState === 'menu') resetGame(); }, { passive:false });
touchLeft.addEventListener('touchend',   e => { e.preventDefault(); input.left = false; }, { passive:false });
touchRight.addEventListener('touchstart', e => { e.preventDefault(); input.right = true; if (gameState === 'menu') resetGame(); }, { passive:false });
touchRight.addEventListener('touchend',   e => { e.preventDefault(); input.right = false; }, { passive:false });

function spawnBulletFromJet(jet){
  const nose = (jet.height/2) + 6;
  const bx = jet.x + Math.cos(jet.angle) * nose;
  const by = jet.y + Math.sin(jet.angle) * nose;
  bullets.push({ x:bx, y:by, vx:Math.cos(jet.angle)*BULLET_SPEED, vy:Math.sin(jet.angle)*BULLET_SPEED, life:2.2 });
}

function spawnBulletFromCar(car){ spawnBulletFromJet(car); }

/* ============================
s   Main loop start
    ============================ */
resizeCanvas();
lastTime = performance.now();
requestAnimationFrame(function loop(t){
  const dt = (t - lastTime) / 1000;
  lastTime = t;
  if (gameState === 'playing') update(dt);
  draw();
  requestAnimationFrame(loop);
});

/* Set initial UI values */
scoreDisplay.textContent = score;
bestScoreDisplay.textContent = highScore;
messageOverlay.style.display = 'block';
</script>
</body>
</html>
