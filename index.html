<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dogfight Destruction v1.0</title>
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #333;
            color: #fff;
            font-family: Arial, sans-serif;
            text-align: center;
        }

        canvas {
            background-color: #000;
            display: block;
            margin: 0 auto;
        }

        h1, p {
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let player = {
            x: canvas.width / 2 - 25,
            y: canvas.height - 60,
            width: 50,
            height: 50,
            speed: 5,
            dx: 0
        };

        let bullets = [];
        let enemies = [];
        let keys = {};
        let score = 0;
        let highScore = localStorage.getItem('dogfightHighScore') || 0;
        let gameOver = false;
        let gameStarted = false;
        let gamePaused = false;
        let enemySpeed = 2;
        let enemySpawnRate = 2000; // in ms
        let lastEnemySpawn = 0;
        let cheatingDetected = false;
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;

        const playerImg = new Image();
        playerImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAsQAAALEBGBJ04gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAADdSURBVEiJrdW9LkMBGIDh909sYCSKaGxs/G9sBFtFEJsYJDbxL2JjGz8g3YAdhQy7C04kznlOS5KRJOfpbpLzAYvAo3bARfAJfGGKAEYtB1yARWAU2Kg2YJgVuATeAAN2gAWwBLR6DbBKYf6FNQB9AK/AXvAAXARGS1P0AKYJbJHvAWeAFaBDEdgR+AfYBNY0xYEVMI1sEfgM+KsaAy/AJjCGrAfYBN5TYBsoAbsBq8AacAJ8BXbVglsAGWAOuAK+M09sPXYvA3aBnTAN7BUP7hfsisAh8CNn5wBNAk78AfuXCQAAAABJRU5ErkJggg==';

        const enemyImg = new Image();
        enemyImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAsQAAALEBGBJ04gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAACVSURBVEiJ7ZYxCsAwDAS/0Puvmy4eILg46SAepKuHoIPgYFkQFDqJ/xYQBIrMv9iXhKQPjJLgCPQAbYBW0AOE/RXwAbaAWmALaAAp8EuwARSAFpACusAOUAUmOflpASeANtAD6ABtYBaQI9gBdAG6QAvg/QCzOflnAPwA7YBYwA7wA6wBSoL/gAfw03Opn/YPSvQBRu4Cy2YmAgIAAAAASUVORK5CYII=';

        document.addEventListener('keydown', (e) => {
            if (!gameStarted && !cheatingDetected) {
                gameStarted = true;
                resetGame();
                gameLoop(0);
            }
            keys[e.key] = true;

            if (e.key === ' ' && !gameOver && !gamePaused && gameStarted) {
                shoot();
            }

            if (e.key.toLowerCase() === 'p' && gameStarted && !gameOver) {
                gamePaused = !gamePaused;
                if (!gamePaused) {
                    requestAnimationFrame(gameLoop);
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        canvas.addEventListener('click', (e) => {
            if (gameOver && !cheatingDetected) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                if (mouseX > canvas.width / 2 - 50 && mouseX < canvas.width / 2 + 50 &&
                    mouseY > canvas.height / 2 + 60 && mouseY < canvas.height / 2 + 90) {
                    resetGame();
                }
            }
        });

        function shoot() {
            const bullet = {
                x: player.x + player.width / 2 - 2.5,
                y: player.y,
                width: 5,
                height: 10,
                speed: 10
            };
            bullets.push(bullet);
        }

        function spawnEnemy(timestamp) {
            if (gameOver || gamePaused) return;

            if (timestamp - lastEnemySpawn > enemySpawnRate) {
                const size = 30;
                const x = Math.random() * (canvas.width - size);
                const y = -size;
                enemies.push({ x, y, width: size, height: size });
                lastEnemySpawn = timestamp;

                // Increase difficulty
                enemySpeed += 0.05;
                if (enemySpawnRate > 500) {
                    enemySpawnRate -= 10;
                }
            }
        }

        function detectCollision(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        function resetGame() {
            player.x = canvas.width / 2 - 25;
            player.y = canvas.height - 60;
            bullets = [];
            enemies = [];
            score = 0;
            gameOver = false;
            gameStarted = true;
            gamePaused = false;
            enemySpeed = 2;
            enemySpawnRate = 2000;
            lastEnemySpawn = 0;
        }

        function detectCheating() {
            if (score > 50000 && enemySpeed < 3) {
                cheatingDetected = true;
                gameOver = true;
                gameStarted = false;
            }
        }

        function drawAntiCheatScreen() {
            ctx.fillStyle = '#f00';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Cheating Detected!', canvas.width / 2, canvas.height / 2 - 40);
            ctx.font = '20px Arial';
            ctx.fillText('Nice try, buddy.', canvas.width / 2, canvas.height / 2);
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
        }

        function drawStartScreen() {
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Tap/Press Left/Right to Steer', canvas.width / 2, canvas.height / 2 - 20);
            ctx.fillText('Spacebar to Shoot', canvas.width / 2, canvas.height / 2 + 10);
            ctx.font = '24px Arial';
            ctx.fillText('Press any key to Start', canvas.width / 2, canvas.height / 2 + 60);
            
            ctx.font = '16px Arial';
            ctx.fillText('Press P to Pause', canvas.width / 2, canvas.height - 30);
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#fff';
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 40);

            ctx.font = '24px Arial';
            ctx.fillText(`Your final score is: ${score}`, canvas.width / 2, canvas.height / 2 + 10);
            ctx.fillText(`High Score: ${highScore}`, canvas.width / 2, canvas.height / 2 + 40);

            // Draw Retry Button
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(canvas.width / 2 - 50, canvas.height / 2 + 60, 100, 30);
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.fillText('Retry', canvas.width / 2, canvas.height / 2 + 82);
        }

        function drawPauseScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Paused', canvas.width / 2, canvas.height / 2);
        }

        function drawScore() {
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 10, 20);
            ctx.fillText(`High Score: ${highScore}`, 10, 45);
        }

        function drawFPS() {
            ctx.fillStyle = '#fff';
            ctx.font = '16px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`FPS: ${fps}`, canvas.width - 10, 20);
        }

        function update(timestamp) {
            if (gameOver) {
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('dogfightHighScore', highScore);
                }
                return;
            }

            if (gamePaused) {
                return;
            }

            if (!gameStarted) {
                return;
            }
            
            detectCheating();
            if (cheatingDetected) {
                return;
            }

            // Player movement
            player.dx = 0;
            if (keys['ArrowLeft'] || keys['a']) {
                player.dx = -player.speed;
            }
            if (keys['ArrowRight'] || keys['d']) {
                player.dx = player.speed;
            }
            player.x += player.dx;

            // Keep player in bounds
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].y -= bullets[i].speed;
                if (bullets[i].y < 0) {
                    bullets.splice(i, 1);
                }
            }

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].y += enemySpeed;
                if (enemies[i].y > canvas.height) {
                    enemies.splice(i, 1);
                }
            }

            // Collision detection
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (detectCollision(bullets[i], enemies[j])) {
                        bullets.splice(i, 1);
                        enemies.splice(j, 1);
                        score += 100;
                        break; 
                    }
                }
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                if (detectCollision(player, enemies[i])) {
                    gameOver = true;
                    break;
                }
            }

            spawnEnemy(timestamp);
        }

        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (cheatingDetected) {
                drawAntiCheatScreen();
                return;
            }

            // Draw player
            ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);

            // Draw bullets
            ctx.fillStyle = '#f00';
            bullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });

            // Draw enemies
            enemies.forEach(enemy => {
                ctx.drawImage(enemyImg, enemy.x, enemy.y, enemy.width, enemy.height);
            });

            if (!gameStarted) {
                drawStartScreen();
            } else if (gameOver) {
                drawGameOver();
            } else if (gamePaused) {
                drawPauseScreen();
            } else {
                drawScore();
                drawFPS();
            }
        }

        function gameLoop(timestamp) {
            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            frameCount++;
            if (timestamp % 1000 < deltaTime) {
                fps = frameCount;
                frameCount = 0;
            }

            update(timestamp);
            draw();

            if (!gameOver && !gamePaused) {
                requestAnimationFrame(gameLoop);
            } else if (gameOver && cheatingDetected) {
                // Stop loop if cheating is detected
                return;
            }
        }

        // Initial call to start the screen
        draw();
    </script>
</body>
</html>
