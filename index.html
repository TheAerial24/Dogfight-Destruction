<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Dogfight Destruction v1.3</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{width:100%;height:100%;overflow:hidden;font-family:'Inter',sans-serif;background:#60A5FA;color:#0b2447}
  #gameCanvas{display:block;background:#bfdbfe;position:absolute;inset:0;z-index:1}
  .ui-container{position:absolute;inset:0;z-index:4;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;align-items:center}
  #scoreDisplay{font-size:2.4rem;font-weight:900;margin-top:1.5rem;text-shadow:0 0 8px rgba(255,255,255,.3);pointer-events:auto;color:#0b2447}
  #messageOverlay{font-size:1.1rem;font-weight:700;text-align:center;animation:pulse 2s infinite;pointer-events:auto;color:#07203b}
  @keyframes pulse{0%{opacity:1;transform:scale(1)}50%{opacity:.8;transform:scale(1.02)}100%{opacity:1}}
  #gameOverModal{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:6;background:#111827;padding:2rem;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.45);text-align:center;display:none;pointer-events:auto;color:#e6eef9;min-width:320px}
  #gameOverModal h1{font-size:2rem;margin-bottom:.5rem}
  #gameOverModal p{font-size:1rem;margin-bottom:1rem;color:#cbd5e1}
  #restartButton{font-family:'Inter',sans-serif;background:#3B82F6;color:#fff;border:none;padding:.8rem 1.4rem;border-radius:8px;font-size:1rem;font-weight:800;cursor:pointer;transition:all .18s ease;box-shadow:0 6px 18px rgba(59,130,246,.25)}
  #restartButton:hover{transform:translateY(-3px);background:#2563EB}
  .touch-zone{position:absolute;top:0;width:50%;height:100%;z-index:3;pointer-events:auto}
  #touchLeft{left:0}
  #touchRight{right:0}
  .shop-btn{font-family:'Inter',sans-serif;background:#4B5563;color:#F3F4F6;border:none;padding:.6rem 1rem;border-radius:6px;font-size:.9rem;font-weight:700;cursor:pointer;transition:all .18s ease;text-align:left}
  .shop-btn:hover{background:#6B7280}
  .shop-btn:disabled{background:#374151;color:#9CA3AF;cursor:not-allowed;opacity:.7}
  .shop-btn span{float:right;opacity:.9}
  .jet-btn.selected{background:#2563eb;color:#fff}

  /* ===== Terminal Intro (CRT) ===== */
  #terminalOverlay{
    position:absolute; inset:0; background:#000; color:#0c0; /* #00CC00 classic CRT */
    display:none; z-index:9999; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  #terminalBox{
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    width:min(900px, 92vw); padding:24px 28px; border:2px solid #093; border-radius:10px;
    background: linear-gradient(180deg, rgba(0,20,0,.9), rgba(0,0,0,.95));
    box-shadow: 0 0 30px rgba(0,255,90,.15), inset 0 0 24px rgba(0,255,70,.08);
  }
  #terminalText{ white-space:pre-wrap; line-height:1.35; font-size:18px; color:#0c0; text-shadow:0 0 6px rgba(0,255,80,.35); min-height:260px }
  .crt-header{ color:#8f8; }
  .crt-rule{ color:#0c0; opacity:.9 }
  #terminalPrompt{
    margin-top:16px; text-align:center; font-weight:800; letter-spacing:.5px; color:#9f9; 
    animation:blink 1.2s steps(2,start) infinite;
    text-shadow:0 0 6px rgba(0,255,80,.35);
  }
  @keyframes blink{ 50%{opacity:.25} }
  /* subtle CRT scanline + vignette */
  #terminalOverlay:after{
    content:''; position:absolute; inset:0; pointer-events:none;
    background:
      linear-gradient(rgba(0,0,0,.0) 50%, rgba(0,0,0,.07) 50%) 0 0/100% 3px,
      radial-gradient(ellipse at center, rgba(0,255,80,.05), rgba(0,0,0,.5) 70%);
    mix-blend-mode:screen;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div class="touch-zone" id="touchLeft"></div>
<div class="touch-zone" id="touchRight"></div>

<div class="ui-container">
  <div id="scoreDisplay">0</div>
  <div id="messageOverlay">Left/Right:Steer - Spacebar:Shoot - P:Pause - E:End<br>Press <strong>P</strong> to Pause</div>
</div>

<div id="gameOverModal">
  <h1>Game Over</h1>
  <p>Score: <strong><span id="finalScore">0</span></strong></p>
  <p>High Score: <strong><span id="bestScore">0</span></strong></p>
  <div id="shopBlocks" style="text-align:left;display:flex;gap:24px;justify-content:center;flex-wrap:wrap">
    <div>
      <h3 style="margin:.25rem 0 .5rem 0;color:#e5e7eb">Upgrades</h3>
      <p style="margin-bottom:.5rem;color:#cbd5e1">Banked Scrap: <strong><span id="totalScrapDisplay">0</span></strong></p>
      <div id="upgradeButtons" style="display:flex;flex-direction:column;gap:.5rem;min-width:280px"></div>
    </div>
    <div>
      <h3 style="margin:.25rem 0 .5rem 0;color:#e5e7eb">Jets</h3>
      <p style="margin-bottom:.5rem;color:#cbd5e1">Banked Scrap: <strong><span id="jetScrapDisplay">0</span></strong></p>
      <div id="jetButtons" style="display:flex;flex-direction:column;gap:.5rem;min-width:280px"></div>
    </div>
  </div>
  <button id="restartButton">Retry</button>
</div>

<!-- ===== Terminal Intro DOM ===== -->
<div id="terminalOverlay">
  <div id="terminalBox">
    <div id="terminalText"></div>
    <div id="terminalPrompt">Press any key to start…</div>
  </div>
</div>

<script>
// ============================
// Core state & constants
// ============================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('scoreDisplay');
const messageOverlay = document.getElementById('messageOverlay');
const gameOverModal = document.getElementById('gameOverModal');
const finalScoreDisplay = document.getElementById('finalScore');
const bestScoreDisplay = document.getElementById('bestScore');
const restartButton = document.getElementById('restartButton');
const touchLeft = document.getElementById('touchLeft');
const touchRight = document.getElementById('touchRight');

const camera = { x:0, y:0 };
const MINIMAP_SCOPE = 4000;
const ENEMY_SPAWN_INVULN = 1.5;
const DEBUG = false;

let gameState = 'menu'; // menu | intro | playing | paused | gameOver
let score = 0, lastTime = 0, gameTime = 0;
let highScore = Number(localStorage.getItem('jet_dogfight_high') || 0);

// Player/enemy tuning
const BASE_PLAYER_SPEED = 120;
const BASE_PLAYER_TURN = 3.5;
const PLAYER = { width:48, height:48, radius:16 };
const ENEMY = { speed:120, turn:2.1, width:48, height:48, radius:16 };
let MAX_ENEMIES = 5;

let spawnTimer = 0, spawnInterval = 4.5;

// Input
const input = { left:false, right:false, fire:false };

// Entities
let player = null, enemies = [], particles = [], contrails = [], bullets = [];
let lastShotTime = 0, SHOT_COOLDOWN = 5 /*ms*/, BULLET_SPEED = 2400, BULLET_RADIUS = 5;

// Anti-cheat
let antiCheatTimer = 0;     // fire + turn 5s
let turnCheatTimer = 0;     // turning 10s
let fireCheatTimer = 0;     // holding fire 10s
let antiCheatTriggered = false;

// Scrap & upgrades & jets
let sessionScrap = 0;
let totalScrap = Number(localStorage.getItem('jet_dogfight_scrap') || 0);
const upgradeConfig = {
  speed: { name:(lvl)=>`Engine (Lvl ${lvl})`, baseCost:50, costScale:1.25, buff:0.03 },
  turn:  { name:(lvl)=>`Ailerons (Lvl ${lvl})`, baseCost:50, costScale:1.25, buff:0.03 },
  scrap: { name:(lvl)=>`Bonus (Lvl ${lvl})`, baseCost:100, costScale:1.5, buff:0.10 },
};
let upgrades = {
  speed: Number(localStorage.getItem('jet_upg_speed') || 0),
  turn:  Number(localStorage.getItem('jet_upg_turn')  || 0),
  scrap: Number(localStorage.getItem('jet_upg_scrap') || 0),
};

// ===== Sprites (SVG) =====
const svgPlayer = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <g transform="translate(32,32)">
    <polygon points="0,-28 8,-8 20,0 8,8 0,28 -8,8 -20,0 -8,-8" fill="#3B82F6" stroke="#1e3a8a" stroke-width="1"/>
    <polygon points="0,-24 5,-8 12,0 5,8 0,24 -5,8 -12,0 -5,-8" fill="#60A5FA"/>
    <ellipse cx="0" cy="-8" rx="4" ry="5" fill="#93C5FD"/>
    <polygon points="-6,12 -10,18 -6,12" fill="#1e3a8a" opacity="0.6"/>
    <polygon points="6,12 10,18 6,12" fill="#1e3a8a" opacity="0.6"/>
  </g>
</svg>`;

const svgEnemy = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <g transform="translate(32,32)">
    <polygon points="0,-28 8,-8 20,0 8,8 0,28 -8,8 -20,0 -8,-8" fill="#EF4444" stroke="#7f1d1d" stroke-width="1"/>
    <polygon points="0,-24 5,-8 12,0 5,8 0,24 -5,8 -12,0 -5,-8" fill="#F87171"/>
    <ellipse cx="0" cy="-8" rx="4" ry="5" fill="#FECACA"/>
    <polygon points="-6,12 -10,18 -6,12" fill="#7f1d1d" opacity="0.6"/>
    <polygon points="6,12 10,18 6,12" fill="#7f1d1d" opacity="0.6"/>
  </g>
</svg>`;

// F-16 (arrow wing, lighter blue/silver)
const svgF16 = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <g transform="translate(32,32)">
    <polygon points="0,-30 9,-10 18,-2 9,6 0,26 -9,6 -18,-2 -9,-10" fill="#60A5FA" stroke="#1e3a8a" stroke-width="1"/>
    <polygon points="0,-26 6,-10 11,-3 6,4 0,22 -6,4 -11,-3 -6,-10" fill="#93C5FD"/>
    <ellipse cx="0" cy="-10" rx="3.5" ry="5" fill="#E5E7EB" opacity="0.85"/>
    <polygon points="-5,12 -8,19 -5,12" fill="#1e3a8a" opacity="0.5"/>
    <polygon points="5,12 8,19 5,12" fill="#1e3a8a" opacity="0.5"/>
  </g>
</svg>`;

// F-22 (delta wing, darker blue-gray)
const svgF22 = `
<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">
  <g transform="translate(32,32)">
    <polygon points="0,-26 12,-10 22,0 12,10 0,22 -12,10 -22,0 -12,-10" fill="#1E40AF" stroke="#0f172a" stroke-width="1"/>
    <polygon points="0,-22 9,-10 16,0 9,8 0,18 -9,8 -16,0 -9,-10" fill="#64748B"/>
    <ellipse cx="0" cy="-8" rx="3.5" ry="4.5" fill="#A7C0D8" opacity="0.9"/>
    <polygon points="-6,8 -10,14 -6,8" fill="#0f172a" opacity="0.45"/>
    <polygon points="6,8 10,14 6,8" fill="#0f172a" opacity="0.45"/>
  </g>
</svg>`;

// SVG → Image helpers
function svgToImg(svg, onload){ const img=new Image(); img.src='data:image/svg+xml;charset=utf-8,'+encodeURIComponent(svg); img.onload=()=>onload&&onload(img); return img; }
const imgPlayerJet = svgToImg(svgPlayer);
const imgEnemyJet  = svgToImg(svgEnemy);
const imgF16       = svgToImg(svgF16);
const imgF22       = svgToImg(svgF22);

// ===== Jet defs (incl. new models) =====
const jets = {
  tigershark:{ key:'tigershark', name:'F-20 Tigershark', desc:'Balanced starter jet.', speed:120, turn:3.5, cost:0,   rotationOffset:0, sprite:'tigershark' },
  starfighter:{ key:'starfighter', name:'F-104 Starfighter', desc:'Very fast, harder to handle.', speed:160, turn:2.3, cost:500, rotationOffset:Math.PI/2, sprite:'tigershark' },
  f16:{ key:'f16', name:'F-16 Fighting Falcon', desc:'Highly maneuverable arrow wing.', speed:140, turn:4.0, cost:1000, rotationOffset:0, sprite:'f16' },
  f22:{ key:'f22', name:'F-22 Raptor', desc:'Stealthy delta wing, fast & agile.', speed:150, turn:4.0, cost:2500, rotationOffset:0, sprite:'f22' },
};
function getSelectedJet(){ return localStorage.getItem('selected_jet') || 'tigershark'; }
function setSelectedJet(k){ localStorage.setItem('selected_jet', k); }

// Boss config/state
const BOSS = {
  BONUS_SCORE: 2000,
  REWARD_SCRAP: 200,
  jet:    { width:96, height:96, radius:32, speed:150, turn:2.3, maxHp:40, color:'#DC2626' },
  turret: { radius:40, fireCooldown:0.8, projSpeed:420, projRadius:6, maxHp:60 },
  hpBar:  { w:360, h:16, y:18 }
};
const BOSS_THRESHOLDS = { jet:5000, turret:10000 };
const bossState = {
  active:false, type:null, current:null, bossShots:[],
  defeatedJet:false, defeatedTurret:false
};
window.bossState = bossState; // debug

// Helpers
function resizeCanvas(){ canvas.width = innerWidth; canvas.height = innerHeight; }
function rand(min,max){ return Math.random()*(max-min)+min; }
function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1,y2-y1); }
function wrapAngle(a){ return (a + Math.PI) % (Math.PI*2) - Math.PI; }
function jet(x,y,angle,speed,turn,type,color){
  return { x,y,angle,speed,turnSpeed:turn,type,color,width:PLAYER.width,height:PLAYER.height,radius:PLAYER.radius,velX:0,velY:0,spawnTime:gameTime,rotationOffset:0, spriteKey:'tigershark' };
}

// ===== Terminal Intro (replaces old scroll) =====
const terminal = (()=>{
  const overlay = document.getElementById('terminalOverlay');
  const textEl  = document.getElementById('terminalText');
  const prompt  = document.getElementById('terminalPrompt');

  const LINES = [
    "=================================================",
    "MISSION BRIEFING — 17 MAY 2005 — IRAQ",
    "",
    "Operation Iron Spear.",
    "Mission: Destroy all targets.",
    "Objective: Reach deep into enemy lines and",
    "destroy their defeses. .",
    "",
    "Be safe pilot, and Good luck.",
    "================================================="
  ];

  let idx = 0, active = false, typer;

  function show(next){
    overlay.style.display = 'block';
    textEl.textContent = "";
    prompt.style.visibility = 'hidden';
    active = true;

    typer = setInterval(()=>{
      if (idx < LINES.length){
        textEl.textContent += (idx ? "\n" : "") + LINES[idx++];
      } else {
        clearInterval(typer);
        prompt.style.visibility = 'visible';
      }
    }, 120); // type line-by-line fast
    // early proceed on key/tap after text appears
    const proceed = ()=>{
      if (!active) return;
      active = false;
      clearInterval(typer);
      overlay.style.display = 'none';
      window.removeEventListener('keydown', proceedOnce);
      window.removeEventListener('touchstart', proceedOnce);
      next && next();
    };
    const proceedOnce = ()=> proceed();
    window.addEventListener('keydown', proceedOnce, { once:true });
    window.addEventListener('touchstart', proceedOnce, { once:true });
  }

  function maybeStart(next){
    gameState = 'intro';
    show(next);
  }

  return { maybeStart };
})();

// UI bits (hearts + scrap counter)
const heartsUI = (()=>{
  const MAX_HEARTS=3; let hearts=MAX_HEARTS; let invUntil=0; let flash=0; let fx=[];
  const wrap = document.createElement('div');
  Object.assign(wrap.style,{position:'absolute',top:'16px',left:'16px',zIndex:1001,display:'flex',gap:'6px',pointerEvents:'none'});
  document.body.appendChild(wrap);
  function heart(op=1,sc=1){ const d=document.createElement('div'); d.style.opacity=op; d.style.transform=`scale(${sc})`; d.style.transition='opacity .2s ease, transform .2s ease'; d.innerHTML=`<svg viewBox="0 0 24 24" width="24" height="24" xmlns="http://www.w3.org/2000/svg"><path d="M12 21s-6.7-4.35-9.33-7.36C-0.48 10.35 1.2 5.7 5.07 5.07 7.3 4.7 9.1 6 12 8.6 14.9 6 16.7 4.7 18.93 5.07c3.86.63 5.55 5.28 2.4 8.57C18.7 16.65 12 21 12 21z" fill="#ef4444" stroke="#7f1d1d" stroke-width="1"/></svg>`; return d; }
  function render(){ wrap.innerHTML=''; for(let i=0;i<MAX_HEARTS;i++) wrap.appendChild(heart(i<hearts?1:.25, i<hearts?1:.9)); }
  render();
  const scrap = document.createElement('div');
  Object.assign(scrap.style,{position:'absolute',top:'16px',left:'120px',fontWeight:800,fontSize:'1.2rem',color:'#fbbf24',textShadow:'0 0 6px rgba(0,0,0,.6)',zIndex:1002,pointerEvents:'none'});
  document.body.appendChild(scrap);
  function updateScrap(){ scrap.textContent = 'Scrap: '+ totalScrap; }
  updateScrap();
  function hitOrGameOver(){ const t=performance.now(); if (t<invUntil) return true; if (hearts>1){ hearts--; render(); invUntil=t+1000; flash=.35; addSparks(player.x,player.y); addSmoke(player.x,player.y); return true; } return false; }
  function addSparks(x,y,n=26){ for(let i=0;i<n;i++){ const a=Math.random()*Math.PI*2,s=140+Math.random()*160,l=.22+Math.random()*.35; fx.push({x,y,dx:Math.cos(a)*s,dy:Math.sin(a)*s,life:l,maxLife:l,size:2+Math.random()*3,color:'#ffd54f'}); } }
  function addSmoke(x,y,n=14){ for(let i=0;i<n;i++){ const a=Math.random()*Math.PI*2,s=30+Math.random()*60,l=.8+Math.random()*.8; fx.push({x,y,dx:Math.cos(a)*s,dy:Math.sin(a)*s,life:l,maxLife:l,size:6+Math.random()*10,color:'rgba(80,80,80,0.5)'}); } }
  function drawOverlay(){ if (flash>0){ ctx.save(); ctx.globalAlpha=flash; ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore(); flash=Math.max(0,flash-0.06); } const dt=1/60; for(let i=fx.length-1;i>=0;i--){ const p=fx[i]; p.x+=p.dx*dt; p.y+=p.dy*dt; p.life-=dt; if (p.life<=0){ fx.splice(i,1); continue; } const a=p.life/p.maxLife; const sx=p.x - camera.x + canvas.width/2; const sy=p.y - camera.y + canvas.height/2; ctx.save(); ctx.globalAlpha=a; ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(sx,sy,p.size,0,Math.PI*2); ctx.fill(); ctx.restore(); } }
  function reset(){ hearts=MAX_HEARTS; invUntil=0; flash=0; fx.length=0; render(); updateScrap(); }
  return { hitOrGameOver, drawOverlay, reset, updateScrap };
})();

// Overheat/cooldown bar
const overheat = (()=>{
  const SHOOT_LIMIT=5.0, COOLDOWN=10.0; let shoot=0, cool=0, state='ready';
  const bar=document.createElement('div'); Object.assign(bar.style,{position:'absolute',bottom:'12px',left:'50%',transform:'translateX(-50%)',width:'220px',height:'14px',background:'rgba(0,0,0,0.36)',borderRadius:'8px',overflow:'hidden',zIndex:1000,pointerEvents:'none'}); const fill=document.createElement('div'); Object.assign(fill.style,{height:'100%',width:'100%',background:'linear-gradient(90deg,#f43f5e 0%,#fb923c 100%)',transition:'width .06s linear'}); bar.appendChild(fill); document.body.appendChild(bar);
  function gateSpawn(){ return state!=='cooldown'; }
  function update(dt){ if (state==='ready'){ if (input.fire){ shoot+=dt; if (shoot>=SHOOT_LIMIT){ state='cooldown'; cool=COOLDOWN; } } } else { cool-=dt; if (cool<=0){ cool=0; shoot=0; state='ready'; } }
    if (state==='ready'){ const rem=Math.max(0,(SHOOT_LIMIT-shoot)/SHOOT_LIMIT); fill.style.width=(rem*100)+'%'; } else { const filled=Math.min(1,(COOLDOWN-cool)/COOLDOWN); fill.style.width=(filled*100)+'%'; } }
  function reset(){ shoot=0; cool=0; state='ready'; fill.style.width='100%'; }
  return { gateSpawn, update, reset };
})();

// Bosses
function spawnBossJet(){
  const a=Math.random()*Math.PI*2; const d=Math.max(canvas.width,canvas.height)*0.8;
  const x=player.x+Math.cos(a)*d, y=player.y+Math.sin(a)*d; const ang=Math.atan2(player.y-y,player.x-x);
  bossState.current = { x,y,angle:ang, speed:BOSS.jet.speed, turn:BOSS.jet.turn, width:BOSS.jet.width, height:BOSS.jet.height, radius:BOSS.jet.radius, hp:BOSS.jet.maxHp, maxHp:BOSS.jet.maxHp, type:'jet' };
  bossState.type='jet'; bossState.active=true;
}
function spawnBossTurret(){
  const x=player.x, y=player.y-120; bossState.current={ x,y,angle:0, hp:BOSS.turret.maxHp, maxHp:BOSS.turret.maxHp, type:'turret', fireTimer:0 };
  bossState.type='turret'; bossState.active=true;
}

// Game API
function resetGame(){
  // base state
  player = jet(0,0,-Math.PI/2, BASE_PLAYER_SPEED, BASE_PLAYER_TURN, 'player', '#3B82F6');
  enemies = []; particles=[]; contrails=[]; bullets=[]; score=0; gameTime=0; spawnTimer=1.8; spawnInterval=4.5; gameState='playing';
  antiCheatTimer=0; turnCheatTimer=0; fireCheatTimer=0; antiCheatTriggered=false;

  // apply selected jet & upgrades
  const selKey = getSelectedJet();
  const j = jets[selKey] || jets.tigershark;
  player.speed=j.speed; player.turnSpeed=j.turn; player.rotationOffset=j.rotationOffset||0; player.spriteKey = j.sprite || 'tigershark';

  // upgrades
  player.speed = player.speed * (1 + upgrades.speed * upgradeConfig.speed.buff);
  player.turnSpeed = player.turnSpeed * (1 + upgrades.turn * upgradeConfig.turn.buff);

  // UI
  gameOverModal.style.display='none'; messageOverlay.style.display='none'; scoreDisplay.style.display='block';
  heartsUI.reset(); overheat.reset();

  // clear boss state
  bossState.active=false; bossState.type=null; bossState.current=null; bossState.bossShots.length=0;
}

function showGameOver(){
  gameState='gameOver'; scoreDisplay.style.display='none'; messageOverlay.style.display='none';
  finalScoreDisplay.textContent = score; if (score>highScore){ highScore=score; localStorage.setItem('jet_dogfight_high', highScore); }
  bestScoreDisplay.textContent = highScore; bankSessionScrap(); updateShopUI();
  gameOverModal.style.display='block'; gameOverModal.querySelector('h1').textContent='Game Over'; restartButton.textContent='Retry';
}

function showAntiCheat(){
  gameState='gameOver'; scoreDisplay.style.display='none'; messageOverlay.style.display='none';
  finalScoreDisplay.textContent = score; if (score>highScore){ highScore=score; localStorage.setItem('jet_dogfight_high', highScore); }
  bestScoreDisplay.textContent = highScore; bankSessionScrap(); updateShopUI();
  gameOverModal.style.display='block'; gameOverModal.querySelector('h1').textContent='Anti Cheat Is: Active'; restartButton.textContent='Restart Game';
}

function spawnEnemy(){ if (enemies.length>=MAX_ENEMIES || bossState.active) return; const a=Math.random()*Math.PI*2; const d=Math.max(canvas.width,canvas.height)*0.8; const x=player.x+Math.cos(a)*d, y=player.y+Math.sin(a)*d; const ang=Math.atan2(player.y-y,player.x-x); enemies.push(jet(x,y,ang, ENEMY.speed, ENEMY.turn, 'enemy', '#EF4444')); }

function createExplosion(x,y,count){ for(let i=0;i<count;i++){ const a=Math.random()*Math.PI*2, s=rand(40,220), l=rand(.6,1.6); particles.push({x,y,dx:Math.cos(a)*s,dy:Math.sin(a)*s,life:l,maxLife:l,size:rand(2,5)}); } }

function spawnBulletFromJet(j){ const nose=(j.height/2)+6; const bx=j.x+Math.cos(j.angle)*nose; const by=j.y+Math.sin(j.angle)*nose; bullets.push({x:bx,y:by,vx:Math.cos(j.angle)*BULLET_SPEED,vy:Math.sin(j.angle)*BULLET_SPEED,life:2.2}); }

function update(dt){
  if (!dt||isNaN(dt)||gameState!=='playing') return; gameTime+=dt;

  // anti-cheat
  if (input.left||input.right){ turnCheatTimer+=dt; if (turnCheatTimer>=10 && !antiCheatTriggered){ antiCheatTriggered=true; createExplosion(player.x,player.y,30); showAntiCheat(); return; } } else { turnCheatTimer=0; }
  if (input.fire && (input.left||input.right)){ antiCheatTimer+=dt; if (antiCheatTimer>=5 && !antiCheatTriggered){ antiCheatTriggered=true; createExplosion(player.x,player.y,30); showAntiCheat(); return; } } else { antiCheatTimer=0; }
  if (input.fire){ fireCheatTimer+=dt; if (fireCheatTimer>=10 && !antiCheatTriggered){ antiCheatTriggered=true; createExplosion(player.x,player.y,30); showAntiCheat(); return; } } else { fireCheatTimer=0; }

  // player steering & drift
  if (input.left)  player.angle -= player.turnSpeed * dt;
  if (input.right) player.angle += player.turnSpeed * dt;
  player.velX += Math.cos(player.angle) * player.speed * dt * 0.55;
  player.velY += Math.sin(player.angle) * player.speed * dt * 0.55;
  player.velX *= 0.92; player.velY *= 0.92; player.x += player.velX; player.y += player.velY;

  // contrails
  contrails.push({x:player.x,y:player.y,angle:player.angle,life:1}); if (contrails.length>360) contrails.shift();

  // enemies AI
  for (let i=enemies.length-1;i>=0;i--){ let e=enemies[i]; const targ=Math.atan2(player.y-e.y, player.x-e.x); let diff=wrapAngle(targ - e.angle); e.angle += Math.min(Math.abs(diff), e.turnSpeed*dt) * Math.sign(diff); e.x += Math.cos(e.angle)*e.speed*dt; e.y += Math.sin(e.angle)*e.speed*dt; }

  // spawns
  spawnTimer -= dt; if (spawnTimer<=0){ spawnEnemy(); spawnTimer=spawnInterval; if (spawnInterval>1.2) spawnInterval*=0.97; }

  // collisions enemy-enemy
  for (let i=enemies.length-1;i>=0;i--){ for (let j=i-1;j>=0;j--){ if (i>=enemies.length||j>=enemies.length) continue; const a=enemies[i], b=enemies[j]; if (gameTime-a.spawnTime<ENEMY_SPAWN_INVULN || gameTime-b.spawnTime<ENEMY_SPAWN_INVULN) continue; if (dist(a.x,a.y,b.x,b.y) < a.radius+b.radius){ createExplosion(a.x,a.y,12); createExplosion(b.x,b.y,12); enemies.splice(i,1); enemies.splice(j,1); score+=200; } } }

  // player vs enemy
  for (let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; if (gameTime-e.spawnTime<ENEMY_SPAWN_INVULN) continue; if (dist(player.x,player.y,e.x,e.y) < player.radius+e.radius){ if (heartsUI.hitOrGameOver()) { enemies.splice(i,1); createExplosion(player.x,player.y,20);
      } else { createExplosion(player.x,player.y,28); showGameOver(); return; } } }

  // particles
  for (let i=particles.length-1;i>=0;i--){ let p=particles[i]; p.x+=p.dx*dt; p.y+=p.dy*dt; p.life-=dt; if (p.life<=0) particles.splice(i,1); }

  // overheat
  overheat.update(dt);

  // firing
  if (input.fire && overheat.gateSpawn()){ if (performance.now()-lastShotTime>SHOT_COOLDOWN){ spawnBulletFromJet(player); lastShotTime=performance.now(); } }

  // bullets update + collisions
  for (let i=bullets.length-1;i>=0;i--){ let b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt; if (b.life<=0){ bullets.splice(i,1); continue; }
    // vs enemies
    for (let j=enemies.length-1;j>=0;j--){ let e=enemies[j]; if (dist(b.x,b.y,e.x,e.y) < BULLET_RADIUS+e.radius){ createExplosion(e.x,e.y,14); enemies.splice(j,1); bullets.splice(i,1); score+=100; sessionScrap += Math.floor(5 * (1 + upgrades.scrap*upgradeConfig.scrap.buff)); break; } }
    // vs boss
    if (bossState.active && bossState.current){ const br = (bossState.type==='jet') ? bossState.current.radius : BOSS.turret.radius; if (dist(b.x,b.y,bossState.current.x,bossState.current.y) < BULLET_RADIUS + br){ bullets.splice(i,1); bossState.current.hp -= 1; particles.push({x:b.x,y:b.y,dx:rand(-60,60),dy:rand(-60,60),life:.3,maxLife:.3,size:3}); if (bossState.current.hp<=0){ createExplosion(bossState.current.x,bossState.current.y,60); score += BOSS.BONUS_SCORE; totalScrap += BOSS.REWARD_SCRAP; localStorage.setItem('jet_dogfight_scrap', totalScrap); heartsUI.updateScrap();
            if (bossState.type==='jet') bossState.defeatedJet=true; if (bossState.type==='turret') bossState.defeatedTurret=true; bossState.active=false; bossState.type=null; bossState.current=null; bossState.bossShots.length=0; }
      }
    }
  }

  // boss logic
  if (!bossState.active){ if (!bossState.defeatedJet && score>=BOSS_THRESHOLDS.jet){ spawnBossJet(); } else if (bossState.defeatedJet && !bossState.defeatedTurret && score>=BOSS_THRESHOLDS.turret){ spawnBossTurret(); } }
  if (bossState.active && bossState.current){ if (bossState.type==='jet'){ const b=bossState.current; const targ=Math.atan2(player.y-b.y, player.x-b.x); let diff=wrapAngle(targ-b.angle); b.angle += Math.min(Math.abs(diff), b.turn*dt) * Math.sign(diff); b.x += Math.cos(b.angle)*b.speed*dt; b.y += Math.sin(b.angle)*b.speed*dt; } else { const b=bossState.current; b.angle = Math.atan2(player.y-b.y, player.x-b.x); b.fireTimer -= dt; if (b.fireTimer<=0){ b.fireTimer = BOSS.turret.fireCooldown; const vx=Math.cos(b.angle)*BOSS.turret.projSpeed, vy=Math.sin(b.angle)*BOSS.turret.projSpeed; bossState.bossShots.push({x:b.x,y:b.y,vx,vy,r:BOSS.turret.projRadius,life:6}); } }
    // boss projectiles
    for (let i=bossState.bossShots.length-1;i>=0;i--){ const s=bossState.bossShots[i]; s.x+=s.vx*dt; s.y+=s.vy*dt; s.life-=dt; if (s.life<=0){ bossState.bossShots.splice(i,1); continue; } if (dist(s.x,s.y,player.x,player.y) < s.r + player.radius){ if (heartsUI.hitOrGameOver()){ bossState.bossShots.splice(i,1); createExplosion(player.x,player.y,20); } else { createExplosion(player.x,player.y,28); showGameOver(); return; } } }
  }

  scoreDisplay.textContent = score;
}

function drawMiniMap(){ const s=140,m=16,x=canvas.width-s-m,y=m, scale=s/MINIMAP_SCOPE; ctx.save(); ctx.translate(x,y); ctx.fillStyle='rgba(0,0,0,.28)'; ctx.fillRect(0,0,s,s); ctx.strokeStyle='#fff'; ctx.lineWidth=1.6; ctx.strokeRect(0,0,s,s);
  ctx.globalAlpha=1; ctx.fillStyle=player.color; ctx.beginPath(); ctx.arc(s/2,s/2,3,0,Math.PI*2); ctx.fill();
  for (let e of enemies){ const rx=e.x-player.x, ry=e.y-player.y; const dx=(rx*scale)+(s/2), dy=(ry*scale)+(s/2); ctx.globalAlpha=(gameTime - e.spawnTime < ENEMY_SPAWN_INVULN)?0.5:1; if (dx>0&&dx<s&&dy>0&&dy<s){ ctx.fillStyle='#EF4444'; ctx.beginPath(); ctx.arc(dx,dy,2,0,Math.PI*2); ctx.fill(); } } ctx.globalAlpha=1; ctx.restore(); }

function getPlayerSpriteImage(){
  switch (player.spriteKey){
    case 'f16': return imgF16;
    case 'f22': return imgF22;
    case 'tigershark': return imgPlayerJet;
    case 'starfighter': return imgPlayerJet; // same model, rotated 90°
    default: return imgPlayerJet;
  }
}

function drawJetEntity(ent){
  ctx.save();
  ctx.translate(ent.x, ent.y);
  const rotation = ent.rotationOffset || 0;
  ctx.rotate(ent.angle + rotation);
  let img;
  if (ent.type==='enemy' || ent.type==='bossJet'){
    img = imgEnemyJet;
  } else if (ent.type==='player'){
    img = getPlayerSpriteImage();
  } else {
    img = imgPlayerJet;
  }
  const w=ent.width||PLAYER.width, h=ent.height||PLAYER.height;
  if (img && img.complete && img.width){
    ctx.drawImage(img, -w/2, -h/2, w, h);
  } else {
    ctx.fillStyle = ent.color||'#3B82F6';
    ctx.beginPath();
    ctx.moveTo(h/2,0);
    ctx.lineTo(-h/2, w/2);
    ctx.lineTo(-h/3,0);
    ctx.lineTo(-h/2, -w/2);
    ctx.closePath();
    ctx.fill();
  }
  if (DEBUG){
    ctx.strokeStyle='#00ff00'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(0,0,ent.radius||PLAYER.radius,0,Math.PI*2); ctx.stroke();
  }
  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  camera.x = (player&&player.x!==undefined)?player.x:0;
  camera.y = (player&&player.y!==undefined)?player.y:0;
  ctx.save();
  ctx.translate(canvas.width/2 - camera.x, canvas.height/2 - camera.y);
  // contrails
  for (let s of contrails){ s.life -= 0.02; ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(s.angle); ctx.fillStyle = `rgba(255,255,255,${Math.max(0, s.life * 0.45)})`; ctx.fillRect(-12,-2.5,24,5); ctx.restore(); }
  // particles
  for (let p of particles){ ctx.fillStyle = `rgba(255,165,0,${Math.max(0,p.life/p.maxLife)})`; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); }
  // bullets
  for (let b of bullets){ ctx.fillStyle='#ffeb3b'; ctx.beginPath(); ctx.arc(b.x,b.y,BULLET_RADIUS,0,Math.PI*2); ctx.fill(); }
  // jets
  if (player) drawJetEntity(player);
  for (let e of enemies) drawJetEntity(e);
  // boss
  if (bossState.active && bossState.current){
    if (bossState.type==='jet'){ const b=bossState.current; drawJetEntity({ ...b, type:'bossJet', color:'#DC2626' }); }
    else { const b=bossState.current; ctx.save(); ctx.translate(b.x,b.y); ctx.fillStyle='#7f1d1d'; ctx.beginPath(); ctx.arc(0,0,BOSS.turret.radius,0,Math.PI*2); ctx.fill(); ctx.rotate(b.angle); ctx.fillStyle='#ef4444'; ctx.fillRect(0,-6,BOSS.turret.radius+18,12); ctx.restore(); }
    for (const s of bossState.bossShots){ ctx.fillStyle='#ff6b6b'; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='rgba(0,0,0,.6)'; ctx.lineWidth=2; ctx.stroke(); }
  }
  ctx.restore();
  if (player) drawMiniMap();
  // boss HP bar
  if (bossState.active && bossState.current){
    const hp=bossState.current.hp, max=bossState.current.maxHp; const frac=Math.max(0,Math.min(1,hp/max));
    const x=(canvas.width-BOSS.hpBar.w)/2, y=BOSS.hpBar.y;
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(x,y,BOSS.hpBar.w,BOSS.hpBar.h);
    ctx.fillStyle='#ef4444'; ctx.fillRect(x,y,BOSS.hpBar.w*frac,BOSS.hpBar.h);
    ctx.strokeStyle='#111'; ctx.lineWidth=2; ctx.strokeRect(x,y,BOSS.hpBar.w,BOSS.hpBar.h);
  }
  heartsUI.drawOverlay();
}

// Shop (upgrades + jets)
function getUpgradeCost(key){ const lvl=upgrades[key]; const cfg=upgradeConfig[key]; return Math.floor(cfg.baseCost * Math.pow(cfg.costScale, lvl)); }
function bankSessionScrap(){ totalScrap += sessionScrap; localStorage.setItem('jet_dogfight_scrap', totalScrap); sessionScrap=0; heartsUI.updateScrap(); }
function buyUpgrade(key){ const cost=getUpgradeCost(key); if (totalScrap>=cost){ totalScrap-=cost; upgrades[key]++; localStorage.setItem('jet_dogfight_scrap', totalScrap); localStorage.setItem('jet_upg_'+key, upgrades[key]); updateShopUI(); } }
function ownedJets(){ const owned=['tigershark']; for (const k in jets){ if (totalScrap>=jets[k].cost) owned.push(k); } return [...new Set(owned)]; }
function updateShopUI(){
  const totalScrapDisplay=document.getElementById('totalScrapDisplay');
  const jetScrapDisplay=document.getElementById('jetScrapDisplay');
  const upgWrap=document.getElementById('upgradeButtons');
  const jetWrap=document.getElementById('jetButtons');
  if (!upgWrap||!jetWrap) return;
  if (totalScrapDisplay) totalScrapDisplay.textContent=totalScrap;
  if (jetScrapDisplay) jetScrapDisplay.textContent=totalScrap;

  // Upgrades
  upgWrap.innerHTML='';
  for (const k in upgradeConfig){
    const lvl=upgrades[k]; const cost=getUpgradeCost(k);
    const btn=document.createElement('button'); btn.className='shop-btn';
    btn.textContent = `${upgradeConfig[k].name(lvl)} — `;
    const span=document.createElement('span'); span.textContent = cost + ' Scrap';
    btn.appendChild(span);
    btn.disabled = totalScrap < cost; btn.title = `Cost: ${cost} Scrap`;
    btn.addEventListener('click',()=>buyUpgrade(k));
    upgWrap.appendChild(btn);
  }

  // Jets
  jetWrap.innerHTML='';
  const owned=ownedJets(); const selected=getSelectedJet();
  const order = ['tigershark','starfighter','f16','f22'];
  for (const k of order){
    const j=jets[k]; if (!j) continue;
    const btn=document.createElement('button'); btn.className='shop-btn jet-btn';
    btn.innerHTML = `${j.name}<span>${owned.includes(k)? (selected===k?'Selected':'Unlocked') : (j.cost+' Scrap')}</span><br><small>${j.desc}</small>`;
    btn.disabled = !owned.includes(k);
    if (selected===k) btn.classList.add('selected');
    btn.addEventListener('click',()=>{ if (!btn.disabled){ setSelectedJet(k); updateShopUI(); } });
    jetWrap.appendChild(btn);
  }
}

// Inputs
restartButton.addEventListener('click', ()=>{ resetGame(); });
addEventListener('resize', resizeCanvas);
addEventListener('keydown', e=>{
  if (gameState==='menu'){ terminal.maybeStart(resetGame); return; }
  if (gameState==='intro'){ /* swallow keys until terminal handler moves on */ return; }

  if (e.key==='p' || e.key==='P'){
    if (gameState==='playing'){ gameState='paused'; messageOverlay.textContent='PAUSED · Press P to Resume'; messageOverlay.style.display='block'; }
    else if (gameState==='paused'){ gameState='playing'; messageOverlay.style.display='none'; }
  }
  if (e.key==='ArrowLeft') input.left=true;
  if (e.key==='ArrowRight') input.right=true;
  if (e.code==='Space') input.fire=true;

  // Dev keys
  if ((e.key==='b'||e.key==='B') && gameState==='playing'){ score += 5000; scoreDisplay.textContent=score; }
  if ((e.key==='e'||e.key==='E') && gameState==='playing'){ createExplosion(player.x,player.y,28); showGameOver(); }
});
addEventListener('keyup', e=>{ if (e.key==='ArrowLeft') input.left=false; if (e.key==='ArrowRight') input.right=false; if (e.code==='Space') input.fire=false; });

touchLeft.addEventListener('touchstart', e=>{ e.preventDefault(); input.left=true; if (gameState==='menu') terminal.maybeStart(resetGame); }, {passive:false});
touchLeft.addEventListener('touchend',   e=>{ e.preventDefault(); input.left=false; }, {passive:false});
touchRight.addEventListener('touchstart', e=>{ e.preventDefault(); input.right=true; if (gameState==='menu') terminal.maybeStart(resetGame); }, {passive:false});
touchRight.addEventListener('touchend',   e=>{ e.preventDefault(); input.right=false; }, {passive:false});

function gameLoop(t){ const dt=(t-lastTime)/1000; lastTime=t; if (gameState==='playing') update(dt); draw(); requestAnimationFrame(gameLoop); }

// Boot
resizeCanvas(); lastTime=performance.now(); requestAnimationFrame(gameLoop);
scoreDisplay.textContent=score; bestScoreDisplay.textContent=highScore; messageOverlay.style.display='block';
updateShopUI();
</script>
</body>
</html>
